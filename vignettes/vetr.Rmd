---
title: "vetR - Keep the Garbage Out"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, hilang='r')
options(width=60)
library(vetr)
```

## Garbage In

R is particularly flexible about data structures so any user-facing code you
write must vet inputs.  If you enforce structural requirements for function
parameters your code will be more robust and easier to write.  It will also be
easier to use since errors will be reported by documented functions and not from
deep in the bowels of un-exported code.

`vetr` takes the tedium out of comprehensive vetting by allowing you to:

* Express structural requirements in a declarative style with templates
* Auto-generate human-friendly error messages

`vetr` is written in C to minimize the overhead of adding parameter checks to
your functions.

## Templates

It is easier to express structural requirements by creating an R object
that embodies them than by writing code that checks them explicitly.  For
example, if we want a scalar numeric we would normally use:

```{r}
x <- 1:3
stopifnot(is.numeric(x), length(x) == 1L)
```

With `vetr`, the equivalent code is:

```{r}
vet(numeric(1L), x)
```

We declare what we want our object to look like and let `vetr` figure out the
details of the comparison.  Notice that the auto-generated error message also
provides more information.

If you are vetting function inputs, you can use the `vetr` function, which works
just like `vet` except that is streamlined for use within functions:

```{r}
fun <- function(x, y) {
  vetr(numeric(1L), logical(1L))
  # ... function code goes here
}
fun(1:2, "hello")
fun(1, "hello")
```

For more details on the `vetr` function see the [Function
Arguments](#function-arguments) section.  For exposition purposes we
will mostly focus on the `vet` function rather than `vetr` since almost
everything that applies to `vet` applies equally to `vetr`.

`vet` handles recursive objects, and as such is particularly well suited to
enforce structural requirements for S3 objects.  Take this "laps" S3 object that
we use to analyze car test drives on race tracks:

```{r}
laps.template <- structure(class="laps",
  list(car=character(1), data=data.frame(lap=numeric(), time=Sys.time()[0])
) )
```

We create a couple of objects to run our tests with:

```{r}
lap.times <- data.frame(lap=1:10, time=cumsum(rnorm(10, 120, 3)))
laps1 <- laps2 <- 
  structure(list(car="corvette z06", data=lap.times), class="laps")
laps2$data <- transform(laps2$data, time=Sys.time() + time)
```

Finally, we vet:

```{r}
vet(laps.template, laps1)   # Lap times should be in POSIXct
vet(laps.template, laps2)   # works
```

Worth noting:

* `vet` recursively checks that the class of the data frame columns (in fact, it
  will recursively check any structure or attribute defined in the template)
* The leading portion of the message (e.g. `laps.3$data$time`) points
  you to the exact location of the problem, and gives you a snippet you can copy
  and paste into the prompt for further scrutiny (e.g. `str(laps.3$data$time)`)

For reference, the same set of checks would look like, and these would get even
more complicated if the nested objects had attributes (e.g. factor levels):

```{r}
vet_stopifnot <- function(x)
  stopifnot(
    is.list(x),
    inherits(x, "laps"),
    length(x) == 2L,
    identical(names(x), c("car", "data")),
    is.character(x$car),
    length(x$car) == 1L,
    is.data.frame(x$data),
    identical(names(x$data), c("lap", "time")),
    is.numeric(x$data$lap),
    identical(mode(x$data$time), "numeric"),
    inherits(x$data$time, c("POSIXct", "POSIXt"))
  )
```
This is more typing, *and* more thinking.  In fact, while creating this
example we had to keep adding tests that we realized `vet` was carrying out
automatically that we had not thought of.

Internally `vet` uses `alike` to compare the template to the test value.  There
are many subtleties to be aware of.  For example, notice how we use a zero row
data.frame in the template to match any number of rows.  See the [alike
vignette](alike.html) for extensive details on how templates work.

## Vetting Expressions

### Test Values with `.`

Templates alone will not let you check data values, or structural aspects that
vary at runtime (e.g. two arguments must be the same length as each other).
To address this `vetr` allows custom expressions:

```{r}
x <- 1:2
y <- c(1, NA)
vet(!anyNA(.), x)
vet(!anyNA(.), y)
```

Any vetting expressions that contain a `.` will be evaluated and vetting
will pass if the result of evaluating the custom expression with the value
substituted for the `.` is a logical vector containing only TRUE.

### Compound Expressions

You can combine any number of templates and custom expressions.  Here, we
combine a template (`numeric(2L)`) with a varying number of custom expressions:

```{r}
vet(numeric(2L) && !anyNA(.), x)
vet(numeric(2L) && !anyNA(.), y)
vet(numeric(2L) && !anyNA(.), 1:10)
vet(numeric(2L) && !anyNA(.) && . > 0L, -(1:2))
```

It is common to allow arguments of varying types.  For example, often times we
allow secondary arguments to be NULL:

```{r}
vet((numeric(2L) && !anyNA(.)) || NULL, 1:2)
vet((numeric(2L) && !anyNA(.)) || NULL, NULL)
vet((numeric(2L) && !anyNA(.)) || NULL, letters)
```

We constructed a compound **vetting expression** by combining two **vetting tokens** with the `&&` and `||` operators.

## Non Standard Evaluation of Vetting Expressions

### Parsing Vetting Expressions

Vetting expressions combine templates and custom tokens delimited by `&&` and
`||`. While superficially vetting expressions look like R expressions, they
are never run through the R evaluator.  Instead, they are substituted
and recursively parsed into tokens.  Each token is then examined to determine
whether it should be treated as a template or as a vetting expression.  For
example:

```{r, eval=FALSE}
logical(1) || (numeric(1) && . %in% 0:1)
```

is parsed as three tokens: `logical(1)`, `numeric(1)`, and `. %in% 0:1`.  Tokens
that contain `.` are interpreted as custom expressions, and tokens that do not
are treated as templates.  In this case the first two tokens are considered
templates, and the last is a custom expression, so the overall vetting
expression will accept scalar logicals, or 0 or 1:

```{r}
vet(logical(1) || (numeric(1) && . %in% 0:1), TRUE)
vet(logical(1) || (numeric(1) && . %in% 0:1), 0)
vet(logical(1) || (numeric(1) && . %in% 0:1), "1")
```

If you need to reference a literal dot (`.`) in a template, you can escape it by
adding another dot so that `.` becomes `..`.  If you want to reference `...`
you'll need to use `....`.  If you have a vetting expression that does not
reference the vetting object (i.e. does not use `.`) you can mark it as a
vetting expression by wrapping it in `.()` (if you want to use a literal
`.()` you can use `..()`).

If you need `&&` or `||` to be interpreted literally you can wrap the call in
`I` to tell `vet` not to recursively parse the expression:

```{r, eval=FALSE}
I(length(a) == length(b) && . %in% 0:1)
```

which will be treated as a single custom vetting token.  `vet` will not
recurse into calls other than to `(`, `&&`, and `||`.  The use of `I`
here is just an example of this behavior and convenient since `I` does not
change the meaning of the vetting token.  Note that an implication of this is
you should not nest template tokens inside functions as `vet` will not
identify them as templates and you may get unexpected results as a result.  For
example:

```{r, eval=FALSE}
I(logical(1L) && my_special_fun(.))
```

will always fail because `logical(1L)` will be interpreted as `FALSE` rather
than as a template token requiring a scalar logical.

### Pre-defining Vetting Tokens

Vetting expressions are interpreted as language objects, so you can save them to
variables by quoting them:

```{r}
TF <- quote(logical(1) && !anyNA(.))  # note `quote`
vet(TF, TRUE)
vet(TF, NA)
vet(TF, 1)
```

Since `vetr` parses and evaluates tokens recursively, you can even combine
pre-stored tokens:

```{r}
ZERO_OR_ONE <- quote(numeric(1) && !is.na(.) && . %in% 0:1)
TF_ish <- quote(TF || ZERO_OR_ONE)
vet(TF_ish, 1)
vet(TF_ish, "0")
```

You can also provide more helpful error messages with `vet_token` for
specific tokens:

```{r}
NONA <- vet_token(!is.na(.), "%s should not contain NAs")
TF <- quote(logical(1L) && NONA)
vet(TF, NA)
```

See `?vet_token` for more details.

### Vetting Expression Parsing and Evaluation Rules

Hopefully you were able to get an intuitive sense of how vetting expressions
work.  If you are interested in the actual rules, read on, otherwise skip to the
next section.

After parsing the vetting expression, `vet` examines each token for the presence
of `.` or `.()`.  If either are present then the `.` values are substituted for
the corresponding variable name (`current` for `vet`, and whatever variable
is matched to the vetting expression for `vetr`).  Then each token
is evaluted in the parent frame.  If the token evaluated was a custom expression
then it is checked for truth.  If not, the result of evaluating the token is
used as a template for an `alike` check against the object being tested, except
for the special case when the template evaluates to a quoted language object.
In that case `vet` recursively applies the same logic to the language
object as described above.

AUTHNOTE: more details on which exact parent frame is used.

### Predefined Tokens

`vetr` comes with many predifined vetting tokens for common cases:

```{r}
vet(NUM.1.POS, 5)
vet(NUM.1.POS, -3)
vet(NUM.1.POS, runif(5))
vet(CHR, letters)
vet(CHR, factor(letters))
```

See `?vet_token` for more details about what predefined tokens are available.


## Performance Considerations

### Benchmarks

Both `validate` and `alike` are written primarily in C to minimize the
performance impact of adding validation checks to your functions.  Performance
is comparable to or faster better than using `stopifnot`.  Here we run our
checks on valid "laps" objects we used to illustrate [vet with complex S3
objects](#complex-s3-objects):

```{r}
library(microbenchmark)
microbenchmark(
  vet(laps.template, laps.4), # vet version
  vet_stopifnot(laps.4)       # validate version
)
```

Performance is optimized for the success case.  Failure cases should still
perform reasonably well, but will be slower than most success cases.

### Templates and Performance

Complex templates will be slower to evalute than simple ones, particularly for
lists with lots of nested elements since `alike` recurses through all template
list elements.

We recommend that you predefine templates in your package and not in the
validation expression since some seemingly innocuous template creation
expressions carry substantial overhead:

```{r}
microbenchmark(data.frame(a=numeric()))
```

In this case the `data.frame` call alone take over 100us.

## Alternatives

### `stopifnot`

`stopifnot` is a fine solution in many cases, but the error messages that result
from it can be cryptic, and it can take a fair bit of effort to set-up
comprehensive tests for complex objects.  One alternative is to use `if/else`
statements in conjunction with `stop` and custom error messages, but that ends
up being even more work still.

### S4 Classes

The natural solution to enforcing structural requirements in R objects is to use
S4 classes.  Unfortunately S3 objects are so prevalent in R that a "backwards
compatible" mechanism for enforcing structure requirement is warranted.

### Valaddin

[valaddin](https://github.com/egnha/valaddin) is a great package by [Eugene
Ha](https://github.com/egnha).  Both `valaddin` and `vetr` are primarily
intended for function input validation.

`valaddin` works by modifying function objects, which makes it easy to add
validation to existing functions in the workspace or functions from packages you
do not control.  The interface is very flexible and allows you to specify pretty
much any validation requirement you wish.

`vetr` requires you to modify the source of a function or to explicitly wrap a
function in another.  `vetr` does have some advantages though:

* Template based validation
* Auto-composition of helpful error messages
* Minimal computational overhead

Here we borrow an example from the `valaddin` vignette to illustrate the
last point:

```{r}
secant <- function(f, x, dx) (f(x + dx) - f(x)) / dx

secant_valaddin <- valaddin::firmly(secant, list(~x, ~dx) ~ is.numeric)
secant_stopifnot <- function(f, x, dx) {
  stopifnot(is.numeric(x), is.numeric(dx))
  secant(f, x, dx)
}
secant_vetr <- function(f, x, dx) {
  vetr(x=numeric(), dx=numeric())
  secant(f, x, dx)
}
microbenchmark(
  secant_valaddin(log, 1, .1),
  secant_stopifnot(log, 1, .1),
  secant_vetr(log, 1, .1)
)
```

In many cases ~100us is not enough of a difference to be concerned with, but
if an R function must be applied repeatedly (e.g. split-apply-combine analysis
with many groups) then it becomes meaningful.

Also, here we illustrate the power of template validation by adding a check to
make sure our function accepts two arguments:

```{r}
f.tpl <- `attributes<-`(function(x, y) NULL, NULL)
secant_vetr2 <- function(f, x, dx) {
  vetr(f.tpl, numeric(), numeric())
  secant(f, x, dx)
}
secant_vetr2(log, 1, .1)
secant_vetr2(sin, 1, .1)
```

### Other Third Party Packages

* [ensurer](https://github.com/smbache/ensurer)
* [types](https://github.com/jimhester/types)
* [argufy](https://github.com/gaborcsardi/argufy)

## Acknowledgements

Thanks to [smbache](https://github.com/smbache) for some ideas I borrowed from
his package [ensurer](https://github.com/smbache/ensurer), in particular for
providing a function to vet objects other than function arguments.  Thanks
also to Hadley Wickham for pointing me to smbache when I asked him about object
vetting.
