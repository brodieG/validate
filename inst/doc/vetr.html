<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Brodie Gaslam" />


<title>vetR - Keep the Garbage Out</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,%0Abody%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E5%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0A%0Apadding%3A%204px%3B%0Awidth%3A%20100%25%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%201em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Ah3%2Esubtitle%20%7B%0Amargin%2Dtop%3A%20%2D23px%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23EEE%3B%0Acolor%3A%20%23333%3B%0A%0A%7D%0Apre%20%7B%0Aborder%3A%202px%20solid%20%23EEE%3B%0Aoverflow%3A%20auto%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%0Amargin%3A%205px%200px%3B%0Apadding%3A%205px%2010px%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Acolor%3A%20%23353%3B%0A%0A%7D%0Adiv%2EsourceCode%20pre%2C%20div%2EsourceCode%20code%20%7B%0Abackground%2Dcolor%3A%20%23FAFAFA%3B%0A%7D%0Adiv%2EsourceCode%20pre%7B%0A%0A%7D%0Adiv%2EsourceCode%20%2B%20pre%2C%0Adiv%2EsourceCode%20%2B%20div%2Ediffobj%5Fcontainer%20%7B%0Amargin%2Dtop%3A%20%2D5px%3B%0A%7D%0Adiv%2Ediffobj%5Fcontainer%20pre%7B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%2C%20h1%20%3E%20code%2C%20h2%20%3E%20code%2C%20h3%20%3E%20code%2C%0Ah4%20%3E%20code%2C%20h5%20%3E%20code%2C%20h6%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0Aline%2Dheight%3A%201%3B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dbottom%3A%203px%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23999%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23999%3B%0Apadding%2Dtop%3A%205px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Apadding%2Dtop%3A%205px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0A%0Acolor%3A%20%23777%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah4%2Eauthor%2C%20h4%2Edate%20%7Bdisplay%3A%20none%3B%7D%0Ah5%2C%20h6%20%7B%0A%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%232255dd%3B%0Afont%2Dweight%3A%20bold%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23555%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23555%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23555%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">vetR - Keep the Garbage Out</h1>
<h4 class="author"><em>Brodie Gaslam</em></h4>


<div id="TOC">
<ul>
<li><a href="#trust-but-verify">Trust, but Verify</a><ul>
<li><a href="#easily">Easily</a></li>
<li><a href="#quickly">Quickly</a></li>
</ul></li>
<li><a href="#declarative-checks-with-templates">Declarative Checks with Templates</a><ul>
<li><a href="#templates">Templates</a></li>
<li><a href="#auto-generated-error-messages">Auto-Generated Error Messages</a></li>
</ul></li>
<li><a href="#vetting-expressions">Vetting Expressions</a></li>
<li><a href="#non-standard-evaluation-of-vetting-expressions">Non Standard Evaluation of Vetting Expressions</a><ul>
<li><a href="#parsing-vetting-expressions">Parsing Vetting Expressions</a></li>
<li><a href="#pre-defining-vetting-tokens">Pre-defining Vetting Tokens</a></li>
<li><a href="#vetting-expression-parsing-and-evaluation-rules">Vetting Expression Parsing and Evaluation Rules</a></li>
<li><a href="#predefined-tokens">Predefined Tokens</a></li>
</ul></li>
<li><a href="#function-arguments">Function Arguments</a></li>
<li><a href="#performance-considerations">Performance Considerations</a><ul>
<li><a href="#benchmarks">Benchmarks</a></li>
<li><a href="#templates-and-performance">Templates and Performance</a></li>
</ul></li>
<li><a href="#alternatives">Alternatives</a><ul>
<li><a href="#stopifnot"><code>stopifnot</code></a></li>
<li><a href="#s4-classes">S4 Classes</a></li>
<li><a href="#valaddin">Valaddin</a></li>
<li><a href="#other-third-party-packages">Other Third Party Packages</a></li>
</ul></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
</ul>
</div>

<div id="trust-but-verify" class="section level2">
<h2>Trust, but Verify</h2>
<div id="easily" class="section level3">
<h3>Easily</h3>
<p>When you write functions that operate on S3 or unclassed objects you can either trust that your inputs will be structured as expected, or tediously check that they are.</p>
<p><code>vetr</code> takes the tedium out of structure verification, so that you can trust, but verify. It lets you express structural requirements declaratively with templates, and it auto-generates human-friendly error messages as needed.</p>
</div>
<div id="quickly" class="section level3">
<h3>Quickly</h3>
<p><code>vetr</code> is written in C to minimize overhead from parameter checks in your functions. It has no dependencies.</p>
</div>
</div>
<div id="declarative-checks-with-templates" class="section level2">
<h2>Declarative Checks with Templates</h2>
<div id="templates" class="section level3">
<h3>Templates</h3>
<p>Declare a template that an object should conform to, and let <code>vetr</code> take care of the rest:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tpl &lt;-<span class="st"> </span><span class="kw">numeric</span>(1L)
<span class="kw">vet</span>(tpl, <span class="dv">1</span>:<span class="dv">3</span>)</code></pre></div>
<pre><code>## [1] &quot;`1:3` should be length 1 (is 3)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(tpl, <span class="st">&quot;hello&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;`\&quot;hello\&quot;` should be type \&quot;numeric\&quot; (is \&quot;character\&quot;)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(tpl, <span class="dv">42</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Zero length templates match any length:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tpl &lt;-<span class="st"> </span><span class="kw">integer</span>()
<span class="kw">vet</span>(tpl, 1L:3L)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(tpl, 1L)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>And for convenience short (&lt;= 100 length) integer-like numerics are considered integer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tpl &lt;-<span class="st"> </span><span class="kw">integer</span>(1L)
<span class="kw">vet</span>(tpl, <span class="dv">1</span>)       <span class="co"># this is a numeric, not an integer</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(tpl, <span class="fl">1.0001</span>)</code></pre></div>
<pre><code>## [1] &quot;`1.0001` should be type \&quot;integer-like\&quot; (is \&quot;double\&quot;)&quot;</code></pre>
<p><code>vetr</code> can compare recursive objects such as lists, and data.frames:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tpl.iris &lt;-<span class="st"> </span>iris[<span class="dv">0</span>, ]      <span class="co"># 0 row DF matches any number of rows in object</span>
iris.fake &lt;-<span class="st"> </span>iris
<span class="kw">levels</span>(iris.fake$Species)[<span class="dv">3</span>] &lt;-<span class="st"> &quot;sibirica&quot;</span>   <span class="co"># tweak levels</span>

<span class="kw">vet</span>(tpl.iris, iris[<span class="dv">1</span>:<span class="dv">10</span>, ])</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(tpl.iris, iris.fake[<span class="dv">1</span>:<span class="dv">10</span>, ])</code></pre></div>
<pre><code>## [1] &quot;`levels((iris.fake[1:10, ])$Species)[3]` should be \&quot;virginica\&quot; (is \&quot;sibirica\&quot;)&quot;</code></pre>
<p>From our declared template <code>iris[0, ]</code>, <code>vetr</code> infers all the required checks. In this case, <code>vet(iris[0, ], iris.fake, stop=TRUE)</code> is equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">stopifnot</span>(
  <span class="kw">is.list</span>(iris.fake), <span class="kw">inherits</span>(iris.fake, <span class="st">&quot;data.frame&quot;</span>),
  <span class="kw">length</span>(iris.fake) ==<span class="st"> </span><span class="dv">5</span>, <span class="kw">is.integer</span>(<span class="kw">attr</span>(iris.fake, <span class="st">'row.names'</span>)),
  <span class="kw">identical</span>(
    <span class="kw">names</span>(iris.fake),
    <span class="kw">c</span>(<span class="st">&quot;Sepal.Length&quot;</span>, <span class="st">&quot;Sepal.Width&quot;</span>, <span class="st">&quot;Petal.Length&quot;</span>, <span class="st">&quot;Petal.Width&quot;</span>, <span class="st">&quot;Species&quot;</span>)
  ),
  <span class="kw">all</span>(<span class="kw">vapply</span>(iris.fake[<span class="dv">1</span>:<span class="dv">4</span>], is.numeric, <span class="kw">logical</span>(1L))),
  <span class="kw">typeof</span>(iris.fake$Species) ==<span class="st"> &quot;integer&quot;</span>, <span class="kw">is.factor</span>(iris.fake$Species),
  <span class="kw">identical</span>(<span class="kw">levels</span>(iris.fake$Species), <span class="kw">c</span>(<span class="st">&quot;setosa&quot;</span>, <span class="st">&quot;versicolor&quot;</span>, <span class="st">&quot;virginica&quot;</span>))
)</code></pre></div>
<pre><code>## Error: identical(levels(iris.fake$Species), c(&quot;setosa&quot;, &quot;versicolor&quot;,  .... is not TRUE</code></pre>
<p><code>vetr</code> saved us a lot of typing, and also a lot of time coming up with the things that need to be compared.</p>
<p>You could just as easily have created templates for nested lists, or data frames in lists. Templates are compared to objects with the <code>alike</code> functions. For a thorough description of templates and how they work see the [<code>alike</code> vignette][2]. For template examples see <code>example(alike)</code>.</p>
</div>
<div id="auto-generated-error-messages" class="section level3">
<h3>Auto-Generated Error Messages</h3>
<p>Let’s revisit the error message:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(tpl.iris, iris.fake[<span class="dv">1</span>:<span class="dv">10</span>, ])</code></pre></div>
<pre><code>## [1] &quot;`levels((iris.fake[1:10, ])$Species)[3]` should be \&quot;virginica\&quot; (is \&quot;sibirica\&quot;)&quot;</code></pre>
<p>It tells us:</p>
<ul>
<li>The reason for the failure</li>
<li>What structure would be acceptable instead</li>
<li>The location of failure <code>levels((iris.fake[1:10, ])$Species)[3]</code></li>
</ul>
<p><code>vetr</code> does what it can to reduce the time from error to resolution. Notice that the location of failure is generated such that you can easily copy it in part or full to the R prompt for further examination.</p>
</div>
</div>
<div id="vetting-expressions" class="section level2">
<h2>Vetting Expressions</h2>
<p>You can combine templates with <code>&amp;&amp;</code> / <code>||</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(<span class="kw">numeric</span>(1L) ||<span class="st"> </span><span class="ot">NULL</span>, <span class="ot">NULL</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(<span class="kw">numeric</span>(1L) ||<span class="st"> </span><span class="ot">NULL</span>, <span class="dv">42</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(<span class="kw">numeric</span>(1L) ||<span class="st"> </span><span class="ot">NULL</span>, <span class="st">&quot;foo&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;`\&quot;foo\&quot;` should be \&quot;NULL\&quot;, or type \&quot;numeric\&quot; (is \&quot;character\&quot;)&quot;</code></pre>
<p>When you need to check values use <code>.</code> to reference the object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(<span class="kw">numeric</span>(1L) &amp;&amp;<span class="st"> </span>. &gt;<span class="st"> </span><span class="dv">0</span>, -<span class="dv">42</span>)  <span class="co"># strictly positive scalar numeric</span></code></pre></div>
<pre><code>## [1] &quot;`-42 &gt; 0` is not TRUE (FALSE)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(<span class="kw">numeric</span>(1L) &amp;&amp;<span class="st"> </span>. &gt;<span class="st"> </span><span class="dv">0</span>, <span class="dv">42</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>You can compose vetting expressions as language objects and combine them:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">scalar.num.pos &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">numeric</span>(1L) &amp;&amp;<span class="st"> </span>. &gt;<span class="st"> </span><span class="dv">0</span>)
foo.or.bar &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">character</span>(1L) &amp;&amp;<span class="st"> </span>. %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">'foo'</span>, <span class="st">'bar'</span>))
vet.exp &lt;-<span class="st"> </span><span class="kw">quote</span>(scalar.num.pos ||<span class="st"> </span>foo.or.bar)

<span class="kw">vet</span>(vet.exp, <span class="dv">42</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(vet.exp, <span class="st">&quot;foo&quot;</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(vet.exp, <span class="st">&quot;baz&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;At least one of these should pass:&quot;                         
## [2] &quot;  - `\&quot;baz\&quot;` should be type \&quot;numeric\&quot; (is \&quot;character\&quot;)&quot;
## [3] &quot;  - `\&quot;baz\&quot; %in% c(\&quot;foo\&quot;, \&quot;bar\&quot;)` is not TRUE (FALSE)&quot;</code></pre>
</div>
<div id="non-standard-evaluation-of-vetting-expressions" class="section level2">
<h2>Non Standard Evaluation of Vetting Expressions</h2>
<div id="parsing-vetting-expressions" class="section level3">
<h3>Parsing Vetting Expressions</h3>
<p>Vetting expressions combine templates and custom tokens delimited by <code>&amp;&amp;</code> and <code>||</code>. While superficially vetting expressions look like R expressions, they are never run through the R evaluator. Instead, they are recursively substituted and parsed into tokens. Each token is then examined to determine whether it should be treated as a template token or a custom token. For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">logical</span>(<span class="dv">1</span>) ||<span class="st"> </span>(<span class="kw">numeric</span>(<span class="dv">1</span>) &amp;&amp;<span class="st"> </span>. %in%<span class="st"> </span><span class="dv">0</span>:<span class="dv">1</span>)</code></pre></div>
<p>is parsed as three tokens: <code>logical(1)</code>, <code>numeric(1)</code>, and <code>. %in% 0:1</code>. Tokens that contain <code>.</code> are interpreted as custom tokens, and tokens that do not are treated as template tokens. In this case the first two tokens are considered templates, and the last is a custom expression, so the overall vetting expression will accept scalar logicals, or 0 or 1:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(<span class="kw">logical</span>(<span class="dv">1</span>) ||<span class="st"> </span>(<span class="kw">numeric</span>(<span class="dv">1</span>) &amp;&amp;<span class="st"> </span>. %in%<span class="st"> </span><span class="dv">0</span>:<span class="dv">1</span>), <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(<span class="kw">logical</span>(<span class="dv">1</span>) ||<span class="st"> </span>(<span class="kw">numeric</span>(<span class="dv">1</span>) &amp;&amp;<span class="st"> </span>. %in%<span class="st"> </span><span class="dv">0</span>:<span class="dv">1</span>), <span class="dv">0</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(<span class="kw">logical</span>(<span class="dv">1</span>) ||<span class="st"> </span>(<span class="kw">numeric</span>(<span class="dv">1</span>) &amp;&amp;<span class="st"> </span>. %in%<span class="st"> </span><span class="dv">0</span>:<span class="dv">1</span>), <span class="st">&quot;1&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;`\&quot;1\&quot;` should be type \&quot;logical\&quot;, or type \&quot;numeric\&quot; (is \&quot;character\&quot;)&quot;</code></pre>
<p>If you need to reference a literal dot (<code>.</code>) in a template, you can escape it by adding another dot so that <code>.</code> becomes <code>..</code>. If you want to reference <code>...</code> you’ll need to use <code>....</code>. If you have a vetting expression that does not reference the vetting object (i.e. does not use <code>.</code>) you can mark it as a vetting expression by wrapping it in <code>.()</code> (if you want to use a literal <code>.()</code> you can use <code>..()</code>).</p>
<p>If you need <code>&amp;&amp;</code> or <code>||</code> to be interpreted literally you can wrap the call in <code>I</code> to tell <code>vet</code> not to recursively parse the expression:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">I</span>(<span class="kw">length</span>(a) ==<span class="st"> </span><span class="kw">length</span>(b) &amp;&amp;<span class="st"> </span>. %in%<span class="st"> </span><span class="dv">0</span>:<span class="dv">1</span>)</code></pre></div>
<p>which will be treated as a single custom token. <code>vet</code> will not recurse into calls other than to <code>(</code>, <code>&amp;&amp;</code>, and <code>||</code>. The use of <code>I</code> here is just an example of this behavior and convenient since <code>I</code> does not change the meaning of the vetting token. An implication of this is you should not nest template tokens inside functions as <code>vet</code> will not identify them as templates and you may get unexpected results. For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">I</span>(<span class="kw">logical</span>(1L) &amp;&amp;<span class="st"> </span><span class="kw">my_special_fun</span>(.))</code></pre></div>
<p>will always fail because <code>logical(1L)</code> is interpreted as <code>FALSE</code> rather than as a template token for a scalar logical.</p>
</div>
<div id="pre-defining-vetting-tokens" class="section level3">
<h3>Pre-defining Vetting Tokens</h3>
<p>Vetting expressions are language objects. Normally the language object is captured via substitution from the <code>vet</code> argument, but you can also store language to variables and use that with <code>vet</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">TF &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">logical</span>(<span class="dv">1</span>) &amp;&amp;<span class="st"> </span>!<span class="kw">anyNA</span>(.))  <span class="co"># note `quote`</span>

<span class="kw">vet</span>(TF, <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(TF, <span class="ot">NA</span>)</code></pre></div>
<pre><code>## [1] &quot;`!anyNA(NA)` is not TRUE (FALSE)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(TF, <span class="dv">1</span>)</code></pre></div>
<pre><code>## [1] &quot;`1` should be type \&quot;logical\&quot; (is \&quot;double\&quot;)&quot;</code></pre>
<p>Since <code>vetr</code> parses and evaluates tokens recursively, you can even combine pre-stored tokens:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ZERO_OR_ONE &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">numeric</span>(<span class="dv">1</span>) &amp;&amp;<span class="st"> </span>!<span class="kw">is.na</span>(.) &amp;&amp;<span class="st"> </span>. %in%<span class="st"> </span><span class="dv">0</span>:<span class="dv">1</span>)
TF_ish &lt;-<span class="st"> </span><span class="kw">quote</span>(TF ||<span class="st"> </span>ZERO_OR_ONE)

<span class="kw">vet</span>(TF_ish, <span class="dv">1</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(TF_ish, <span class="st">&quot;0&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;`\&quot;0\&quot;` should be type \&quot;logical\&quot;, or type \&quot;numeric\&quot; (is \&quot;character\&quot;)&quot;</code></pre>
<p>You can also provide more helpful error messages with <code>vet_token</code> for specific tokens:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">NONA &lt;-<span class="st"> </span><span class="kw">vet_token</span>(!<span class="kw">is.na</span>(.), <span class="st">&quot;%sshould not contain NAs&quot;</span>)
TF &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">logical</span>(1L) &amp;&amp;<span class="st"> </span>NONA)
<span class="kw">vet</span>(TF, <span class="ot">NA</span>)</code></pre></div>
<pre><code>## [1] &quot;`NA` should not contain NAs&quot;</code></pre>
<p>See <code>?vet_token</code> for more details.</p>
</div>
<div id="vetting-expression-parsing-and-evaluation-rules" class="section level3">
<h3>Vetting Expression Parsing and Evaluation Rules</h3>
<p>Hopefully you were able to get an intuitive sense of how vetting expressions work. If you are interested in the actual rules, read on, otherwise skip to the next section.</p>
<p>After parsing the vetting expression, <code>vet</code> examines each token for the presence of <code>.</code> or <code>.()</code>. If either are present then the <code>.</code> values are substituted for the corresponding variable name (<code>current</code> for <code>vet</code>, and whatever variable is matched to the vetting expression for <code>vetr</code>). Then each token is evaluted in the parent frame. If the token evaluated was a custom expression then it is checked for truth. If not, the result of evaluating the token is used as a template for an <code>alike</code> check against the object being tested, except for the special case when the template evaluates to a language object. In that case <code>vet</code> recursively applies the same logic to the language object as described above.</p>
<p>Some care is required when using language objects themselves as templates. For example, suppose we want our template to be a call to <code>&amp;&amp;</code>, then we must quote it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(<span class="kw">quote</span>(x &amp;&amp;<span class="st"> </span>y), <span class="kw">quote</span>(a ||<span class="st"> </span>b))</code></pre></div>
<pre><code>## [1] &quot;`quote(a || b)[[1]]` should be a call to `&amp;&amp;` (is a call to `||`)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(<span class="kw">quote</span>(x &amp;&amp;<span class="st"> </span>y), <span class="kw">quote</span>(a &amp;&amp;<span class="st"> </span>b))</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Since <code>quote</code> is not a call to <code>(</code>, <code>&amp;&amp;</code>, or <code>||</code> it is evaluated and the resulting language object is used as a template token. Once a token is evaluated it is no longer recursively substituted and parsed, which is why <code>x</code> and <code>y</code> are not each treated as tokens themselves. If we want to store the vetting expression in a variable then we must double quote:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">LANG.AND &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">quote</span>(x &amp;&amp;<span class="st"> </span>y))
<span class="kw">vet</span>(LANG.AND, <span class="kw">quote</span>(a ||<span class="st"> </span>b))</code></pre></div>
<pre><code>## [1] &quot;`quote(a || b)[[1]]` should be a call to `&amp;&amp;` (is a call to `||`)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(LANG.AND, <span class="kw">quote</span>(a &amp;&amp;<span class="st"> </span>b))</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>For more details on language templates see the <a href="alike.html">alike vignette</a>.</p>
</div>
<div id="predefined-tokens" class="section level3">
<h3>Predefined Tokens</h3>
<p><code>vetr</code> comes with many predefined vetting tokens for common cases:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(NUM<span class="fl">.1</span>.POS, <span class="dv">5</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(NUM<span class="fl">.1</span>.POS, -<span class="dv">3</span>)</code></pre></div>
<pre><code>## [1] &quot;`-3` should contain only positive values, but has negatives&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(NUM<span class="fl">.1</span>.POS, <span class="kw">runif</span>(<span class="dv">5</span>))</code></pre></div>
<pre><code>## [1] &quot;`runif(5)` should be length 1 (is 5)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(CHR, letters)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vet</span>(CHR, <span class="kw">factor</span>(letters))</code></pre></div>
<pre><code>## [1] &quot;`factor(letters)` should be type \&quot;character\&quot; (is \&quot;integer\&quot;)&quot;</code></pre>
<p>See <code>?vet_token</code> for more details about what predefined tokens are available.</p>
</div>
</div>
<div id="function-arguments" class="section level2">
<h2>Function Arguments</h2>
<p>The <code>vetr</code> function streamlines parameter checks in functions. It behaves just like <code>vet</code>, except that you need only specify the vetting expressions. The objects to vet are captured from the function environment:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fun &lt;-<span class="st"> </span>function(x, y, z) {
  <span class="kw">vetr</span>(
    <span class="kw">matrix</span>(<span class="kw">numeric</span>(), <span class="dt">ncol=</span><span class="dv">3</span>),
    <span class="kw">logical</span>(1L),
    <span class="kw">character</span>(1L) &amp;&amp;<span class="st"> </span>. %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>)
  )
  <span class="ot">TRUE</span>  <span class="co"># do work...</span>
}
<span class="kw">fun</span>(<span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">12</span>, <span class="dv">3</span>), <span class="ot">TRUE</span>, <span class="st">&quot;baz&quot;</span>)</code></pre></div>
<pre><code>## Error in fun(x = matrix(1:12, 3), y = TRUE, z = &quot;baz&quot;): For argument `x`, `matrix(1:12, 3)` should have 3 columns (has 4)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fun</span>(<span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">12</span>, <span class="dv">4</span>), <span class="ot">TRUE</span>, <span class="st">&quot;baz&quot;</span>)</code></pre></div>
<pre><code>## Error in fun(x = matrix(1:12, 4), y = TRUE, z = &quot;baz&quot;): For argument `z`, `&quot;baz&quot; %in% c(&quot;foo&quot;, &quot;bar&quot;)` is not TRUE (FALSE)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fun</span>(<span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">12</span>, <span class="dv">4</span>), <span class="ot">TRUE</span>, <span class="st">&quot;foo&quot;</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>The arguments to <code>vetr</code> are matched to the arguments of the enclosing function in the same way as with <code>match.call</code>. For example, if we wished to vet just the third argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fun &lt;-<span class="st"> </span>function(x, y, z) {
  <span class="kw">vetr</span>(<span class="dt">z=</span><span class="kw">character</span>(1L) &amp;&amp;<span class="st"> </span>. %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>))
  <span class="ot">TRUE</span>  <span class="co"># do work...</span>
}
<span class="kw">fun</span>(<span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">12</span>, <span class="dv">3</span>), <span class="ot">TRUE</span>, <span class="st">&quot;baz&quot;</span>)</code></pre></div>
<pre><code>## Error in fun(x = matrix(1:12, 3), y = TRUE, z = &quot;baz&quot;): For argument `z`, `&quot;baz&quot; %in% c(&quot;foo&quot;, &quot;bar&quot;)` is not TRUE (FALSE)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fun</span>(<span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">12</span>, <span class="dv">4</span>), <span class="ot">TRUE</span>, <span class="st">&quot;bar&quot;</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Vetting expressions work the same way with <code>vetr</code> as they do with <code>vet</code>.</p>
</div>
<div id="performance-considerations" class="section level2">
<h2>Performance Considerations</h2>
<div id="benchmarks" class="section level3">
<h3>Benchmarks</h3>
<p><code>vetr</code> is written primarily in C to minimize the performance impact of adding validation checks to your functions. Performance is comparable to or faster better than using <code>stopifnot</code>. Here we run our checks on valid “laps” objects we used to illustrate <a href="#complex-s3-objects">vet with complex S3 objects</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)
<span class="kw">microbenchmark</span>(
  <span class="kw">vet</span>(laps.template, laps2),
  <span class="kw">vet_stopifnot</span>(laps2)
)</code></pre></div>
<pre><code>## Error: inherits(x$data$time, c(&quot;POSIXct&quot;, &quot;POSIXt&quot;)) is not TRUE</code></pre>
<p>Performance is optimized for the success case. Failure cases should still perform reasonably well, but will be slower than most success cases.</p>
</div>
<div id="templates-and-performance" class="section level3">
<h3>Templates and Performance</h3>
<p>Complex templates will be slower to evaluate than simple ones, particularly for lists with lots of nested elements. Note however that the cost of the vetting expression is a function of the complexity of the template, not that of the value being vetted.</p>
<p>We recommend that you predefine templates in your package and not in the validation expression since some seemingly innocuous template creation expressions carry substantial overhead:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">microbenchmark</span>(<span class="kw">data.frame</span>(<span class="dt">a=</span><span class="kw">numeric</span>()))</code></pre></div>
<pre><code>## Unit: microseconds
##                       expr     min      lq    mean   median
##  data.frame(a = numeric()) 100.316 104.998 118.353 107.3095
##        uq     max neval
##  114.7355 294.597   100</code></pre>
<p>In this case the <code>data.frame</code> call alone take over 100us.</p>
</div>
</div>
<div id="alternatives" class="section level2">
<h2>Alternatives</h2>
<div id="stopifnot" class="section level3">
<h3><code>stopifnot</code></h3>
<p><code>stopifnot</code> is a fine solution in many cases, but the error messages that result from it can be cryptic, and it can take a fair bit of effort to set-up comprehensive tests for complex objects.</p>
</div>
<div id="s4-classes" class="section level3">
<h3>S4 Classes</h3>
<p>The natural solution to enforcing structural requirements in R objects is to use S4 classes. Unfortunately S3 objects are so prevalent in R that a “backwards compatible” mechanism for enforcing structure requirement is warranted.</p>
</div>
<div id="valaddin" class="section level3">
<h3>Valaddin</h3>
<p><a href="https://github.com/egnha/valaddin">valaddin</a> is a great package by <a href="https://github.com/egnha">Eugene Ha</a>. Both <code>valaddin</code> and <code>vetr</code> are primarily intended for function input vetting.</p>
<p><code>valaddin</code> works by modifying function objects, which makes it easy to add validation to existing functions in the workspace or functions from packages you do not control. The interface is very flexible and allows you to specify pretty much any vetting requirement you wish.</p>
<p><code>vetr</code> requires you to modify the source of a function or to explicitly wrap a function in another. <code>vetr</code> does have some advantages though:</p>
<ul>
<li>Declarative template based vetting</li>
<li>Auto-composition of helpful error messages</li>
<li>Minimal computational overhead</li>
</ul>
<p>Here we borrow an example from the <code>valaddin</code> vignette to illustrate the last point:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(valaddin)</code></pre></div>
<pre><code>## Error in library(valaddin): there is no package called 'valaddin'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">secant &lt;-<span class="st"> </span>function(f, x, dx) (<span class="kw">f</span>(x +<span class="st"> </span>dx) -<span class="st"> </span><span class="kw">f</span>(x)) /<span class="st"> </span>dx

secant_valaddin &lt;-<span class="st"> </span>valaddin::<span class="kw">firmly</span>(secant, <span class="kw">list</span>(~x, ~dx) ~<span class="st"> </span>is.numeric)</code></pre></div>
<pre><code>## Error in loadNamespace(name): there is no package called 'valaddin'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">secant_stopifnot &lt;-<span class="st"> </span>function(f, x, dx) {
  <span class="kw">stopifnot</span>(<span class="kw">is.numeric</span>(x), <span class="kw">is.numeric</span>(dx))
  <span class="kw">secant</span>(f, x, dx)
}
secant_vetr &lt;-<span class="st"> </span>function(f, x, dx) {
  <span class="kw">vetr</span>(<span class="dt">x=</span><span class="kw">numeric</span>(), <span class="dt">dx=</span><span class="kw">numeric</span>())
  <span class="kw">secant</span>(f, x, dx)
}

<span class="kw">microbenchmark</span>(
  <span class="kw">secant_valaddin</span>(log, <span class="dv">1</span>, .<span class="dv">1</span>),
  <span class="kw">secant_stopifnot</span>(log, <span class="dv">1</span>, .<span class="dv">1</span>),
  <span class="kw">secant_vetr</span>(log, <span class="dv">1</span>, .<span class="dv">1</span>)
)</code></pre></div>
<pre><code>## Error in secant_valaddin(log, 1, 0.1): could not find function &quot;secant_valaddin&quot;</code></pre>
<p>In many cases ~100us is not enough of a difference to be concerned with, but if an R function must be applied repeatedly (e.g. split-apply-combine analysis with many groups) then it becomes meaningful.</p>
</div>
<div id="other-third-party-packages" class="section level3">
<h3>Other Third Party Packages</h3>
<ul>
<li><a href="https://github.com/smbache/ensurer">ensurer</a></li>
<li><a href="https://github.com/jimhester/types">types</a></li>
<li><a href="https://github.com/gaborcsardi/argufy">argufy</a></li>
</ul>
</div>
</div>
<div id="acknowledgements" class="section level2">
<h2>Acknowledgements</h2>
<p>Thanks to <a href="https://github.com/smbache">smbache</a> for some ideas I borrowed from his package <a href="https://github.com/smbache/ensurer">ensurer</a>, in particular for providing a function to vet objects other than function arguments. Thanks also to Hadley Wickham for pointing me to smbache when I asked him about object vetting.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
