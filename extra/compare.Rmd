---
title: "Parameter Validation Functions"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: ../vignettes/styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE)
library(vetr)
library(assertive)
library(assertthat)
library(ensurer)
library(checkmate)
library(valaddin)
```

## Prevent Garbage In

Most functions expect their parameters to be of specific types, structures, or
values.  If we allow functions to operate on parameters that do not conform to
the expectations then we could get in the best case difficult to debug errors
from the bowels of the function, and in the worst silent undefined behavior.

Systematically vetting function parameters is as tedious as it is important, but
fortunately many packages exist to assist with the process.  We will review
those packages and assess them across these dimensions:

* Ease of use for the function developer incorporating parameter checks
* Computing overhead
* Ease of use for end users

We will review the following packages / functions:

* `stopifnot` by R Core
* [`asserthat`](https://github.com/hadley/assertthat) by Hadley Wickham
* [`assertive`](https://www.r-pkg.org/pkg/assertive) by Richie Cotton
* [`checkmate`](https://github.com/mllg/checkmate) by Michael Lang
* [`ensurer`](https://github.com/smbache/ensurer) by Stefan M. Bache
* [`valaddin`](https://github.com/egnha/valaddin) by Eugene Ha (note, we are
  reviewing v0.1.0, and recently released v0.3.0 implements many changes)
* [`vetr`](https://github.com/brodieG/vetr) by Yours Truly

Not all of these packages are specifically designed to test function parameters,
but they can all be used that way.  We will also focus on "out of the box"
functionality.

The following packages also perform related tasks, although we do not review
them here:

* [`validate`](https://github.com/data-cleaning/validate) by Mark van
  der Loo and Edwin de Jonge, with a primary focus on validating data in data
  frames and similar data structures
* [`assertr`](https://github.com/ropensci/assertr) by Tony Fischetti, also
  focused on data validation in data frames and similar structures
* [`types`](https://github.com/jimhester/types) by Jim Hester, which implements
  but does not enforce type hinting
* [`argufy`](https://github.com/gaborcsardi/argufy) by Gábor Csárdi, which
  implements parameter validation via roxygen tags (not released to CRAN)

## Result Summary

### Overview

Every package is compared to`stopifnot` across several dimensions.  The only
objective measurements here are the benchmarks.  Everything else is my opinion
which you can safely assume is biased in favor of my own package `vetr`.
Notwithstanding my dog in the fight, I tried to be objective.

Scores are in relation to `stopifnot`, with positive numbers meaning the package
performs better than `stopifnot`, and negative numbers that it performs worse.

### Ease of Use for Function Developer

<table>
<tr>
  <th colspan=13 style='bgcolor: #EEE;'>Ease of Use for Developer
<tr>
  <th>&nbsp;
  <th colspan=2>asserthat <th colspan=2>assertive <th colspan=2>checkmate
  <th colspan=2>ensurer <th colspan=2>valaddin <th colspan=2>vetr

<tr>
<th>Learning Curve
  <td style='weight: bold;'>&nbsp;0<td>like `stopifnot`
  <td style='color: red; weight: bold;'>-2<td>hundreds of functions
  <td style='color: red; weight: bold;'>-2<td>dozens of complex functions
  <td style='color: orange; weight: bold;'>-1<td>new concepts
  <td style='color: red; weight: bold;'>-2<td>new complex concepts
  <td style='color: orange; weight: bold;'>-1<td>new concepts

<tr>
<th>Expressive Power
  <td style='weight: bold;'>&nbsp;0<td>like `stopifnot`
  <td style='color: green; weight: bold;'>+1<td>Functions for most circumstances
  <td style='color: #0F0; weight: bold;'>+2<td>Excellent for vectors
  <td style='weight: bold;'>&nbsp;0<td>like `stopifnot`
  <td style='color: green; weight: bold;'>+1<td>Complex relations between args
  <td style='color: #0F0; weight: bold;'>+2<td>Excellent for complex object
  structure

<tr>
<th> Extensibility
  <td style='weight: bold;'>&nbsp;0<td>like `stopifnot`
  <td style='weight: bold;'>&nbsp;0<td>like `stopifnot`
  <td style='color: green; weight: bold;'>+1<td>Tools to build custom assertions
  <td style='color: green; weight: bold;'>+1<td>Tools to build custom assertions
  <td style='color: green; weight: bold;'>+1<td>Tools to build custom assertions
  <td style='color: #0F0; weight: bold;'>+2<td>Store vetting expressions as lang
  objects

<tr>
<th colspan=13 style='bgcolor: #EEE;'>Performance
<tr>
  <th>&nbsp;
  <th colspan=2>asserthat <th colspan=2>assertive <th colspan=2>checkmate
  <th colspan=2>ensurer <th colspan=2>valaddin <th colspan=2>vetr

<tr>
<th>Simple checks
  <td style='weight: bold;'>&nbsp;0<td>comparable to `stopifnot`
  <td style='color: red; weight: bold;'>-2<td>2 orders of magnitude slower
  <td style='weight: bold;'>&nbsp;0<td>comparable to `stopifnot`
  <td style='color: orange; weight: bold;'>-1<td>1 order of magnitude slower
  <td style='color: orange; weight: bold;'>-1<td>1 order of magnitude slower
  <td style='weight: bold;'>&nbsp;0<td>comparable to `stopifnot`

<tr>
<th>Large vectors
  <td style='weight: bold;'>&nbsp;0<td>comparable to `stopifnot`
  <td style='color: red; weight: bold;'>-2<td>3 orders of magnitude slower
  <td style='weight: bold;'>+1<td>Comparisons in C
  <td style='weight: bold;'>&nbsp;0<td>comparable to `stopifnot`
  <td style='weight: bold;'>&nbsp;0<td>comparable to `stopifnot`
  <td style='weight: bold;'>+1<td>Comparisons in C
<tr>

<th>Complex Objects
  <td style='weight: bold;'>&nbsp;0<td>comparable to `stopifnot`
  <td style='color: red; weight: bold;'>-2<td>3 orders of magnitude slower
  <td style='weight: bold;'>+1<td>Comparisons in C
  <td style='weight: bold;'>&nbsp;0<td>comparable to `stopifnot`
  <td style='weight: bold;'>&nbsp;0<td>comparable to `stopifnot`
  <td style='weight: bold;'>+1<td>Comparisons in C

</table>

Definitions:

* Learning curve: basically how long it took me to figure out how to implement
  the various checks that we test later in this document
* Expressive power: how succinctly we can express the constraints on the
  parameters
* Extensibility: how easy it is to build and re-use checking patterns


## Ease of Use for Developers

* Learning curve
* Extensibility


* How many functions does the developer need to learn
* Degree of difficulty in learning those functions
    * assertthat
* Do those functions reduce the amount of work a developer must put in
    * Somewhat

## Computing Overhead

* Trivial checks
* Long vectors value checks
* Complex objects



There are many alternative packages that can be used for function parameter
validation.  Most have broader scope than just this task, but we will focus on
comparing them only in this context.

## Alternatives

### Tested Alternatives

We can split these functions / packages into two rough categories:

1. Those that rely on standard R expressions along with wrapper functions to
   assess outcomes and produce error messages (wrapper based)
2. Those that implement assertion functions that explicitly check for particular
   structures / values (function based)

For example, the venerable `stopifnot` belongs to the first category.  So do
`vetr`, `asserthat`, `ensurer`, and `valaddin`.  On the other hand `assertive`
and `checkmate` belong to the second category.  One way the difference between
these class of package manifests is through the number of functions in the
package:

```{r list_funs, echo=FALSE}
list_funs <- function(space) {
  object.names <- ls(space)
  objects <- mget(object.names, envir=as.environment(space))
  names(objects)[sapply(objects, is.function)]
}
```
```{r}
sapply(
  c('vetr', 'assertthat', 'ensurer', 'valaddin', 'assertive', 'checkmate'),
  function(x) length(list_funs(sprintf("package:%s", x)))
)
```

Even when accounting for the duplicate/variation functions in `assertive` and
`checkmate`, the overall function count is substantially higher.  This can be
convenient when there is a function available for your exact use case, but
sorting though the lists to find that function can be daunting.

### Other Related Packages


## Simple Parameter Checks

### The Function

We want to check the following three parameter function:

```{r, eval=FALSE}
function(
  num,     # numeric vector
  opt,     # scalar character in c("one", "two", "three")
  flag     # TRUE or FALSE
)
```
```{r}
valid.opts <- c("one", "two", "three")   # values valid in `opts`
```

### Wrapper Based

We start with `stopifnot`, since it is the simplest and most well known option:

```{r}
f1_stopifnot <- function(num, opt, flag) {
  stopifnot(
    is.numeric(num),
    isTRUE(opt %in% valid.opts),
    length(flag) == 1 && !is.na(flag) && is.logical(flag)
  )
  TRUE
}
f1_stopifnot(letters, "four", TRUE)
```

The `vetr` implementation is very similar to `stopifnot`, except we can use
templates and `.` as shorthand for the matched parameter:

```{r}
f1_vetr <- function(num, opt, flag) {
  vetr(
    numeric(),                 # template
    isTRUE(. %in% valid.opts), # custom token (contains `.`)
    logical(1L) && !is.na(.)   # template && custom token
  )
  TRUE
}
f1_vetr(letters, "four", TRUE)
```

In fact, we *must* use `.` if we want `vetr` to evaluate a token as an R
expression instead of treating it as a template.  Notice how the template
`logical(1L)` is equivalent to `length(flag) == 1 && is.logical(flag)`.
Parameters must match the structure of their corresponding templates.  For more
details on templates and validation expressions see the vignette
`vignette('vetr', package='vetr')`.

Worth noting:

* Parameters are positionally matched to vetting expressions to save typing,
  although you can use names as well (e.g. `vetr(num=numeric(), ...)`)
* In addition to being told what the object isn't, you are also told what it is
* The object is referenced by its name in the calling scope (`letters`) instead
  of its name in the function environment (`num`)
* The function call is returned so you know where the error happened

Let's continue on with the other wrapper style packages:

```{r}
f1_assertthat <- function(num, opt, flag) {
  assert_that(
    is.numeric(num),
    opt %in% valid.opts,
    is.flag(flag) && !is.na(flag)
  )
  TRUE
}
f1_assertthat(letters, "four", TRUE)

f1_ensurer <- function(num, opt, flag) {
  ensure(num, is.numeric(.))
  ensure(opt, . %in% valid.opts)
  ensure(flag, length(.) == 1 && !is.na(.) && is.logical(.))
  TRUE
}
f1_ensurer(letters, "four", TRUE)

f1_valaddin <- firmly(
  function(num, opt, flag) TRUE,
  list(~num) ~ is.numeric, # equivalently `vld_numeric(~num)`
  list(~opt) ~ {. %in% valid.opts},
  list(~flag) ~ {length(.) == 1 && !is.na(.) && is.logical(.)}
)
f1_valaddin(letters, "four", TRUE)
```

Worth noting:

* `asserthat`, `valaddin`, and `ensurer` only pass if test expressions return
  single TRUE values, unlike `stopifnot` and `vetr` which also accept all TRUE
  logical vectors
* Wrapper style packages can implement specific checker functions: for example
  `assertthat` implements `is.flag` function, `valaddin` implements
  `vld_boolean` (unused here), etc.
* `valaddin`:
    * reports all failing conditions, not just the first failing one
    * reports the failing call, just like `vetr`
    * modifies an *existing* function

### Function Based

```{r}
f1_checkmate <- function(num, opt, flag) {
  assertNumeric(num)
  assertChoice(opt, valid.opts)
  assertFlag(flag)
  TRUE
}
f1_checkmate(letters, "four", TRUE)

f1_assertive <- function(num, opt, flag) {
  assert_is_numeric(num)
  assert_is_scalar(opt)
  assert_all_are_true(opt %in% valid.opts)
  assert_is_a_bool(flag)
  assert_all_are_not_na(flag)
  TRUE
}
f1_assertive(letters, "four", TRUE)
```

The "function" based packages have specialized functions for a variety of
checks.  Sometimes this can lead to particularly concise checks, and also more
helpful error messages since each specific function has more context about the
validation expectations.

### Benchmarks

We benchmark the functions with `mb`, a thin wrapper around `microbenchmark`
(see the [appendix](#appendix) for its definition).  Note that the `mean`
numbers are likely skewed by outlier timings caused by `rmarkdown`.

```{r mb_define, echo=FALSE}
mb <- function(...) {
  mb.call <- match.call()
  mb.call[[1]] <- quote(microbenchmark::microbenchmark)

  mb.res <- summary(eval(mb.call, envir=parent.frame()))
  mb.res <- mb.res[order(mb.res$median), ]
  mb.res[, -1] <- lapply(
    mb.res[, -1], function(x) format(round(x), big.mark=",")
  )
  cat(
    sprintf("Unit: %s, neval: %s\n\n", attr(mb.res, 'unit'), mb.res$neval[1])
  )
  print(mb.res[, c('expr', 'lq', 'median', 'uq', 'mean')], quote=FALSE)
}
```
```{r, echo=FALSE}
mb(
  f1_assertive(pi, "three", TRUE),
  f1_assertthat(pi, "three", TRUE),
  f1_ensurer(pi, "three", TRUE),
  f1_checkmate(pi, "three", TRUE),
  f1_stopifnot(pi, "three", TRUE),
  f1_valaddin(pi, "three", TRUE),
  f1_vetr(pi, "three", TRUE)
)
```

`stopifnot` leads the way, which is not surprising given the simplicity of the
checks involved.  `checkmate` is second, although both `vetr` and `asserthat`
are in the same neighborhood.  Performance drops off substantially after
`asserthat`.

One could argue that the performance differences here are trivial.  After all,
even the slowest approach clocks in under 3 milliseconds.  However, given the
prevalence of split-apply-combine style analysis, where a single function could
be applied to thousands or even millions of data groups, the performance
differences shown here can have a substantial impact on overall computation
time.

## Strictly Positive

We will increase the complexity somewhat by requiring that the numeric vector be
strictly positive.

```{r}
f2_vetr <- function(num) {
  vetr(numeric() && all_bw(., 0, Inf,  bounds="(]"))
}
f2_stopifnot <- function(num) {
  stopifnot(is.numeric(num), !anyNA(num), all(num > 0))
}
f2_assertthat <- function(num) {
  assert_that(is.numeric(num), !anyNA(num), all(num > 0))
}
f2_ensurer <- function(num) {
  ensure(num, is.numeric(.), !anyNA(num), all(num > 0))
}
f2_valaddin <- firmly(
  function(num) NULL,
  ~ is.numeric, ~ {!anyNA(.)}, ~ {all(. > 0)}
)
f2_checkmate <- function(num) {
  qassert(num, "n*(0,]")
}
f2_assertive <- function(num) {
  assert_all_are_in_left_open_range(num, lower=0)
}
```
```{r}
str.pos.vec <- runif(5e4) + 1  # test with a 50K long vector
```
```{r, echo=FALSE}
mb(times=10,
  f2_assertive(str.pos.vec),
  f2_assertthat(str.pos.vec),
  f2_ensurer(str.pos.vec),
  f2_checkmate(str.pos.vec),
  f2_stopifnot(str.pos.vec),
  f2_valaddin(str.pos.vec),
  f2_vetr(str.pos.vec)
)
```

`vetr` is now the fastest option, although this is primarily because we use
`vetr::all_bw` instead of the equivalent `!anyNA(.) && all(. > 0)` expression.
`all_bw` is implemented in C and avoids the intermediate vectors required to
evaluate the standard R version.  `checkmate` does the same with `qassert`.
Notice also that for both `vetr` and `checkmate` the mean and median timings are
close.  This is likely because these functions do not require the
occasional expensive garbage collections caused by intermediate vectors.

## A Complex Object

Here we wish to verify that an input conforms to the structure of the `iris`
built-in data set.

```{r}
iris.tpl <- vetr::abstract(iris) # equivalently: iris[0, ]
iris.fake <- iris
levels(iris.fake$Species)[3] <- "sibirica"   # tweak levels
```
We will narrow the field to `vetr`, `stopifnot`, and `checkmate` primarily
```{r}
f3_vetr <- function(x) {
  vetr(iris.tpl)
}
f3_vetr(iris.fake)

f3_stopifnot <- function(x) {
  stopifnot(
    is.list(x), inherits(x, "data.frame"),
    length(x) == 5, is.integer(attr(x, 'row.names')),
    identical(names(x), names(iris.tpl)),
    typeof(x$Species) == "integer", is.factor(x$Species),
    identical(levels(x$Species), levels(iris.tpl$Species))
  )
}
f3_stopifnot(iris.fake)

f3_checkmate <- function(x) {
  assertDataFrame(
    x, types=c("numeric", "numeric", "numeric", "numeric", "factor")
  )
  assertNames(names(x), identical.to=names(iris.tpl))
  assertFactor(x$Species, levels=levels(iris.tpl$Species))
}
f3_checkmate(iris.fake)
```

This is where the power of the template becomes apparent.  Rather than
painstakingly generating a list of all the comparisons required to validate the
object, we point to an existing object to use as a template. `vetr` recursively
traverses the template and the function parameter in parallel, ensuring that the
structure of the template elements is matched by those of the parameter
elements.  Even if an existing object does not exist, it is easier to manually
construct such a template than to specify all the function calls required to
confirm conformance to the template structure.

In addition to the compact representation, notice the error message:

> `levels(iris.fake$Species)[3]` should be "virginica" (is "sibirica")

This is by far the most useful of the three as it highlights the exact location
of the failure in a form you can immediately copy-paste into your prompt for
further examination.

Additionally, since all the `vetr` comparisons are done internally in C, `vetr`
is the fastest option:

```{r, echo=FALSE}
mb(
  f3_vetr(iris),
  f3_stopifnot(iris),
  f3_checkmate(iris)
)
```

## Comparison Dimensions

* Error message
  * Reports call like stop
  * Explains what it is not
  * Uses language from calling scope
  * Explains what it is
* Style (wrapper / function)
* Median timings
    * Simple tests
    * Values
    * Data frame
    * S3 Object
* Compound expressions

### Or Checks

## Comparison

## Appendix

```{r list_funs}
```

```{r mb_define}
```

