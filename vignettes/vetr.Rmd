---
title: "vetR - Keep the Garbage Out"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, hilang='r')
options(width=60)
library(vetr)
```

## Garbage In...

R is flexible about data structures so any user-facing code you write must vet
inputs.  If you enforce structural requirements for function parameters your
code will be more robust.  It will also be easier to use since errors will be
reported by documented functions and not from deep in the bowels of un-exported
code.

`vetr` takes the tedium out of comprehensive vetting by allowing you to express
structural requirements in a declarative style with templates, and by
auto-generating human-friendly error messages.  It is written in C to minimize
the overhead of parameter checks in your functions.

## Templates

`vetr` implements declarative vetting via templates.  For example, to check for
a scalar numeric we use:

```{r}
x <- 1:3
vet(numeric(1L), x)
```

Compare to the standard approach:

```{r}
stopifnot(is.numeric(x), length(x) == 1L)
```

We **declare** what we want our object to look like and let `vetr` figure out
the details of the comparison.  Notice that the auto-generated error message
also provides more information than the traditional approach does.

If you are vetting function inputs, you can use the `vetr` function, which works
just like `vet` except that is streamlined for use within functions:

```{r}
fun <- function(x, y) {
  vetr(numeric(1L), logical(1L))
  TRUE   # do work...
}
fun(1:2, "hello")
fun(1, "hello")
```

For more details on the `vetr` function see the [Function
Arguments](#function-arguments) section.  For exposition purposes we
will mostly focus on the `vet` function rather than `vetr` since almost
everything that applies to `vet` applies equally to `vetr`.

`vet` handles recursive objects, and as such is particularly well suited to
enforce structural requirements for S3 objects.  Take this "laps" S3 object that
we use to analyze car test drives on race tracks:

```{r}
laps.template <- structure(class="laps",
  list(car=character(1), data=data.frame(lap=numeric(), time=Sys.time()[0])
) )
```

We create a couple of objects to run our tests with:

```{r}
lap.times <- data.frame(lap=1:10, time=cumsum(rnorm(10, 120, 3)))
laps1 <- laps2 <-
  structure(list(car="corvette z06", data=lap.times), class="laps")
laps2$data <- transform(laps2$data, time=Sys.time() + time)
```

Finally, we vet:

```{r}
vet(laps.template, laps1)   # Lap times should be in POSIXct
vet(laps.template, laps2)   # works
```

Worth noting:

* `vet` recursively checks that the class of the data frame columns (in fact, it
  will recursively check any structure or attribute defined in the template)
* The leading portion of the message (e.g. `laps.3$data$time`) points
  you to the exact location of the problem, and gives you a snippet you can copy
  and paste into the prompt for further scrutiny (e.g. `str(laps.3$data$time)`)

For reference, the same set of checks would look like, and these would get even
more complicated if the nested objects had attributes (e.g. factor levels):

```{r}
vet_stopifnot <- function(x)
  stopifnot(
    is.list(x),
    inherits(x, "laps"),
    length(x) == 2L,
    identical(names(x), c("car", "data")),
    is.character(x$car),
    length(x$car) == 1L,
    is.data.frame(x$data),
    identical(names(x$data), c("lap", "time")),
    is.numeric(x$data$lap),
    identical(mode(x$data$time), "numeric"),
    inherits(x$data$time, c("POSIXct", "POSIXt"))
  )
```
This is more typing, *and* more thinking.  In fact, while creating this
example we had to keep adding tests that we realized `vet` was carrying out
automatically that we had not thought of.

Internally `vet` uses `alike` to compare the template to the test value.  There
are many subtleties to be aware of.  For example, notice how we use a zero row
data.frame in the template to match any number of rows.  See the [alike
vignette](alike.html) for extensive details on how templates work.

## Vetting Expressions

### Test Values with `.`

Templates alone will not let you check data values, or structural aspects that
vary at runtime (e.g. two arguments must be the same length as each other).
To address this `vetr` allows custom expressions:

```{r}
x <- 1:2
y <- c(1, NA)
vet(!anyNA(.), x)
vet(!anyNA(.), y)
```

Any vetting expressions that contain a `.` will be evaluated and vetting
will pass if the result of evaluating the custom expression with the value
substituted for the `.` is a logical vector containing only TRUE.

### Compound Expressions

You can combine any number of templates and custom expressions.  Here, we
combine a template (`numeric(2L)`) with a varying number of custom expressions:

```{r}
vet(numeric(2L) && !anyNA(.), x)
vet(numeric(2L) && !anyNA(.), y)
vet(numeric(2L) && !anyNA(.), 1:10)
vet(numeric(2L) && !anyNA(.) && . > 0L, -(1:2))
```

We can allow arguments to match several types.  For example, often we
allow secondary arguments to be NULL:

```{r}
vet((numeric(2L) && !anyNA(.)) || NULL, 1:2)
vet((numeric(2L) && !anyNA(.)) || NULL, NULL)
vet((numeric(2L) && !anyNA(.)) || NULL, letters)
```

We constructed a compound **vetting expression** by combining two **vetting tokens** with the `&&` and `||` operators.

## Non Standard Evaluation of Vetting Expressions

### Parsing Vetting Expressions

Vetting expressions combine templates and custom tokens delimited by `&&` and
`||`. While superficially vetting expressions look like R expressions, they
are never run through the R evaluator.  Instead, they are recursively
substituted and parsed into tokens.  Each token is then examined to determine
whether it should be treated as a template token or a custom token.  For
example:

```{r, eval=FALSE}
logical(1) || (numeric(1) && . %in% 0:1)
```

is parsed as three tokens: `logical(1)`, `numeric(1)`, and `. %in% 0:1`.  Tokens
that contain `.` are interpreted as custom tokens, and tokens that do not
are treated as template tokens.  In this case the first two tokens are
considered templates, and the last is a custom expression, so the overall
vetting expression will accept scalar logicals, or 0 or 1:

```{r}
vet(logical(1) || (numeric(1) && . %in% 0:1), TRUE)
vet(logical(1) || (numeric(1) && . %in% 0:1), 0)
vet(logical(1) || (numeric(1) && . %in% 0:1), "1")
```

If you need to reference a literal dot (`.`) in a template, you can escape it by
adding another dot so that `.` becomes `..`.  If you want to reference `...`
you'll need to use `....`.  If you have a vetting expression that does not
reference the vetting object (i.e. does not use `.`) you can mark it as a
vetting expression by wrapping it in `.()` (if you want to use a literal
`.()` you can use `..()`).

If you need `&&` or `||` to be interpreted literally you can wrap the call in
`I` to tell `vet` not to recursively parse the expression:

```{r, eval=FALSE}
I(length(a) == length(b) && . %in% 0:1)
```

which will be treated as a single custom token.  `vet` will not recurse into
calls other than to `(`, `&&`, and `||`.  The use of `I` here is just an example
of this behavior and convenient since `I` does not change the meaning of the
vetting token.  An implication of this is you should not nest template tokens
inside functions as `vet` will not identify them as templates and you may get
unexpected results.  For example:

```{r, eval=FALSE}
I(logical(1L) && my_special_fun(.))
```

will always fail because `logical(1L)` is interpreted as `FALSE` rather than as
a template token for a scalar logical.

### Pre-defining Vetting Tokens

Vetting expressions are language objects.  Normally the language object is
captured via substitution from the `vet` argument, but you can also store language to variables and use that with `vet`:

```{r}
TF <- quote(logical(1) && !anyNA(.))  # note `quote`

vet(TF, TRUE)
vet(TF, NA)
vet(TF, 1)
```

Since `vetr` parses and evaluates tokens recursively, you can even combine
pre-stored tokens:

```{r}
ZERO_OR_ONE <- quote(numeric(1) && !is.na(.) && . %in% 0:1)
TF_ish <- quote(TF || ZERO_OR_ONE)

vet(TF_ish, 1)
vet(TF_ish, "0")
```

You can also provide more helpful error messages with `vet_token` for
specific tokens:

```{r}
NONA <- vet_token(!is.na(.), "%sshould not contain NAs")
TF <- quote(logical(1L) && NONA)
vet(TF, NA)
```

See `?vet_token` for more details.

### Vetting Expression Parsing and Evaluation Rules

Hopefully you were able to get an intuitive sense of how vetting expressions
work.  If you are interested in the actual rules, read on, otherwise skip to the
next section.

After parsing the vetting expression, `vet` examines each token for the presence
of `.` or `.()`.  If either are present then the `.` values are substituted for
the corresponding variable name (`current` for `vet`, and whatever variable
is matched to the vetting expression for `vetr`).  Then each token
is evaluted in the parent frame.  If the token evaluated was a custom expression
then it is checked for truth.  If not, the result of evaluating the token is
used as a template for an `alike` check against the object being tested, except
for the special case when the template evaluates to a language object.  In that
case `vet` recursively applies the same logic to the language object as
described above.

Some care is required when using language objects themselves as templates.  For
example, suppose we want our template to be a call to `&&`, then we must quote
it:

```{r}
vet(quote(x && y), quote(a || b))
vet(quote(x && y), quote(a && b))
```

Since `quote` is not a call to `(`, `&&`, or `||` it is evaluated and the
resulting language object is used as a template token.  Once a token is
evaluated it is no longer recursively substituted and parsed, which is why `x`
and `y` are not each treated as tokens themselves.  If we want to store
the vetting expression in a variable then we must double quote:

```{r}
LANG.AND <- quote(quote(x && y))
vet(LANG.AND, quote(a || b))
vet(LANG.AND, quote(a && b))
```

For more details on language templates see the [alike vignette](alike.html).

### Predefined Tokens

`vetr` comes with many predefined vetting tokens for common cases:

```{r}
vet(NUM.1.POS, 5)
vet(NUM.1.POS, -3)
vet(NUM.1.POS, runif(5))
vet(CHR, letters)
vet(CHR, factor(letters))
```

See `?vet_token` for more details about what predefined tokens are available.

## Function Arguments

The `vetr` function streamlines parameter checks in functions.  It behaves just
like `vet`, except that you need only specify the vetting expressions.  The
objects to vet are captured from the function environment:

```{r}
fun <- function(x, y, z) {
  vetr(
    matrix(numeric(), ncol=3),
    logical(1L),
    character(1L) && . %in% c("foo", "bar")
  )
  TRUE  # do work...
}
fun(matrix(1:12, 3), TRUE, "baz")
fun(matrix(1:12, 4), TRUE, "baz")
fun(matrix(1:12, 4), TRUE, "foo")
```

The arguments to `vetr` are matched to the arguments of the enclosing function
in the same way as with `match.call`.  For example, if we wished to vet just
the third argument:

```{r}
fun <- function(x, y, z) {
  vetr(z=character(1L) && . %in% c("foo", "bar"))
  TRUE  # do work...
}
fun(matrix(1:12, 3), TRUE, "baz")
fun(matrix(1:12, 4), TRUE, "bar")
```

Vetting expressions work the same way with `vetr` as they do with `vet`.

## Performance Considerations

### Benchmarks

`vetr` is written primarily in C to minimize the performance impact of adding
validation checks to your functions.  Performance is comparable to or faster
better than using `stopifnot`.  Here we run our checks on valid "laps" objects
we used to illustrate [vet with complex S3 objects](#complex-s3-objects):

```{r}
library(microbenchmark)
microbenchmark(
  vet(laps.template, laps2),
  vet_stopifnot(laps2)
)
```

Performance is optimized for the success case.  Failure cases should still
perform reasonably well, but will be slower than most success cases.

### Templates and Performance

Complex templates will be slower to evaluate than simple ones, particularly for
lists with lots of nested elements.  Note however that the cost of the vetting
expression is a function of the complexity of the template, not that of the
value being vetted.

We recommend that you predefine templates in your package and not in the
validation expression since some seemingly innocuous template creation
expressions carry substantial overhead:

```{r}
microbenchmark(data.frame(a=numeric()))
```

In this case the `data.frame` call alone take over 100us.

## Alternatives

### `stopifnot`

`stopifnot` is a fine solution in many cases, but the error messages that result
from it can be cryptic, and it can take a fair bit of effort to set-up
comprehensive tests for complex objects.

### S4 Classes

The natural solution to enforcing structural requirements in R objects is to use
S4 classes.  Unfortunately S3 objects are so prevalent in R that a "backwards
compatible" mechanism for enforcing structure requirement is warranted.

### Valaddin

[valaddin](https://github.com/egnha/valaddin) is a great package by [Eugene
Ha](https://github.com/egnha).  Both `valaddin` and `vetr` are primarily
intended for function input vetting.

`valaddin` works by modifying function objects, which makes it easy to add
validation to existing functions in the workspace or functions from packages you
do not control.  The interface is very flexible and allows you to specify pretty
much any vetting requirement you wish.

`vetr` requires you to modify the source of a function or to explicitly wrap a
function in another.  `vetr` does have some advantages though:

* Declarative template based vetting
* Auto-composition of helpful error messages
* Minimal computational overhead

Here we borrow an example from the `valaddin` vignette to illustrate the
last point:

```{r}
library(valaddin)

secant <- function(f, x, dx) (f(x + dx) - f(x)) / dx

secant_valaddin <- valaddin::firmly(secant, list(~x, ~dx) ~ is.numeric)
secant_stopifnot <- function(f, x, dx) {
  stopifnot(is.numeric(x), is.numeric(dx))
  secant(f, x, dx)
}
secant_vetr <- function(f, x, dx) {
  vetr(x=numeric(), dx=numeric())
  secant(f, x, dx)
}

microbenchmark(
  secant_valaddin(log, 1, .1),
  secant_stopifnot(log, 1, .1),
  secant_vetr(log, 1, .1)
)
```

In many cases ~100us is not enough of a difference to be concerned with, but
if an R function must be applied repeatedly (e.g. split-apply-combine analysis
with many groups) then it becomes meaningful.

### Other Third Party Packages

* [ensurer](https://github.com/smbache/ensurer)
* [types](https://github.com/jimhester/types)
* [argufy](https://github.com/gaborcsardi/argufy)

## Acknowledgements

Thanks to [smbache](https://github.com/smbache) for some ideas I borrowed from
his package [ensurer](https://github.com/smbache/ensurer), in particular for
providing a function to vet objects other than function arguments.  Thanks
also to Hadley Wickham for pointing me to smbache when I asked him about object
vetting.
