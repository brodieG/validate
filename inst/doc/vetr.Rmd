---
title: "vetR - Keep the Garbage Out"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE)
options(width=60)
```

## Garbage In

R is particularly flexible about data structures so any user-facing code you
write must vet inputs.  If you rigorously enforce structural requirements for
function parameters your code will be more robust and easier to
write.  It will also be easier to use since errors will be reported by
documented functions and not from deep in the bowels of un-exported code.

`vetr` lets you vet your inputs with minimal overhead:

* Structural requirements expressed with minimal code via templates
* Friendly auto-generated errors explain why an error occurred
* Written completely in C to minimize computation cost

## Templates

It is easier to express structural requirements by creating an R object
that embodies them than by writing code that checks them explicitly.  For
example, if we want a scalar numeric we would normally use:

```{r}
x <- 1:3
stopifnot(is.numeric(x), length(x) == 1L)
```

With `vetr`, the equivalent code is :

```{r}
library(vetr)
vet(numeric(1L), x)
```

`vetr` handles recursive objects, and as such is particularly well suited to
enforce structural requirements for S3 objects.  Take our "laps" S3 object that
we use to analyze car test drives on race tracks:

```{r}
laps.template <- structure(
  class="laps",
  list(
    car=character(1),
    data=data.frame(lap=numeric(), time=Sys.time()[0])
) )
```

We create several objects to run our tests with:

```{r}
lap.times <- data.frame(lap=1:10, time=cumsum(rnorm(10, 120, 3)))
laps.1 <- structure(lap.times, class="laps")
laps.2 <- structure(list("corvette z06", lap.times), class="laps")
laps.3 <- laps.4 <- setNames(laps.2, c("car", "data"))
laps.4$data <- transform(laps.4$data, time=Sys.time() + time)
```

Finally, we vet:

```{r}
vet(laps.template, laps.1)   # Forgot to include car
vet(laps.template, laps.2)   # Missing names
vet(laps.template, laps.3)   # Lap times should be in POSIXct
vet(laps.template, laps.4)   # works
```

Worth noting:

* `vet` recursively checks that the class of the data frame columns
* The leading portion of the message (e.g. `laps.3$data$time`) points
  you to the exact location of the problem, and gives you a snippet you can copy
  and paste into the prompt for further scrutiny (e.g. `str(laps.3$data$time)`)

For reference, the same set of checks would look like:

```{r, eval=FALSE}
stopifnot(
  is.list(laps.1),
  inherits(laps.1, "laps"),
  length(laps.1) == 2L,
  identical(names(laps.1), c("car", "data")),
  is.character(laps.1$car),
  length(laps.1$car) == 1L,
  is.data.frame(laps.1$data),
  identical(names(laps.1$data), c("lap", "time")),
  is.numeric(laps.1$lap),
  identical(mode(laps.1$time), "numeric"),
  inherits(laps.1$time, c("POSIXct", "POSIXt"))
)
```

Internally `vet` uses `alike` to compare the template to the test value.  See
the [alike
vignette](http://htmlpreview.github.io/?https://raw.githubusercontent.com/brodieG/alike/master/inst/doc/alike.html)
for extensive details on how templates work.

## Custom Expressions

Templates alone will no let you check data values, or structural aspects that
vary at runtime (e.g. two arguments must be the same length as each other).
To address this `vetr` allows custom expressions:

```{r}
x <- 1:2
y <- c(1, NA)
vet(!anyNA(.), x)
vet(!anyNA(.), y)
```

Any vetting expressions that contain a `.` will be evaluated and vetting
will pass if the result of evaluating the custom expression with the value
substituted for the `.` is a logical vector containing only TRUE.

## Compound Expressions

You can combine any number of templates and custom expressions.  Here, we
combine a template (`numeric(2L)`) with a varying number of custom expressions:

```{r}
vet(numeric(2L) && !anyNA(.), x)
vet(numeric(2L) && !anyNA(.), y)
vet(numeric(2L) && !anyNA(.), 1:10)
vet(numeric(2L) && !anyNA(.) && . > 0L, -(1:2))
```

It is common to allow arguments of varying types.  For example, often times we
allow secondary arguments to be NULL:

```{r}
vet((numeric(2L) && !anyNA(.)) || NULL, 1:2)
vet((numeric(2L) && !anyNA(.)) || NULL, NULL)
vet((numeric(2L) && !anyNA(.)) || NULL, letters)
```

We constructed a compound **validation expression** by combining two **validation tokens** with the `&&` and `||` operators.

## Non Standard Evaluation of Vetting Expressions

### Parsing Vetting Expressions

Vetting expressions combine templates and custom tokens delimited by `&&` and
`||`. While superficially vetting expressions look like R expressions, they
are never run through the R evaluator.  Instead, they are substituted
and recursively parsed into tokens.  Each token is then examined to determine
whether it should be treated as a template or as a validation expression.  For
example:

```{r, eval=FALSE}
logical(1) || (numeric(1) && . %in% 0:1)
```

is parsed as three tokens: `logical(1)`, `numeric(1)`, and `. %in% 0:1`.  Tokens
that contain `.` are interpreted as custom expressions, and tokens that do not
are treated as templates.  In this case the first two tokens are considered
templates, and the last is a custom expression, so the overall validation
expression will accept scalar logicals, or 0 or 1:

```{r}
vet(logical(1) || (numeric(1) && . %in% 0:1), TRUE)
vet(logical(1) || (numeric(1) && . %in% 0:1), 0)
vet(logical(1) || (numeric(1) && . %in% 0:1), "1")
```

If you need to reference a literal dot (`.`) in a template, you can escape it by
adding another dot so that `.` becomes `..`.  If you want to reference `...`
you'll need to use `....`.  If you have a validation expression that does not
reference the validation object (i.e. does not use `.`) you can mark it as a
validation expression by wrapping it in `.()` (if you want to use a literal
`.()` you can use `..()`).

If you need `&&` or `||` to be interpreted literally you can wrap the call in
`I` to tell `validate` not to recursively parse the expression:

```{r, eval=FALSE}
I(length(a) == length(b) && . %in% 0:1)
```

which will be treated as a single custom validation token.  `validate` will not
recurse into calls other than to `(`, `&&`, and `||`.  The use of `I`
here is just an example of this behavior and convenient since `I` does not
change the meaning of the vetting token.  Note that an implication of this is
you should not nest template tokens inside functions as `validate` will not
identify them as templates and you may get unexpected results as a result.  For
example:

```{r, eval=FALSE}
I(logical(1L) && my_special_fun(.))
```

will always fail because `logical(1L)` will be interpreted as `FALSE` rather
than as a template token requiring a scalar logical.

### Pre-defining Vetting Tokens

Vetting expressions are interpreted as language objects, so you can save them to
variables by quoting them:

```{r}
TF <- quote(logical(1) && !anyNA(.))  # note `quote`
vet(TF, TRUE)
vet(TF, NA)
vet(TF, 1)
```

Since `vetr` parses and evaluates tokens recursively, you can even combine
pre-stored tokens:

```{r}
ZERO_OR_ONE <- quote(numeric(1) && !is.na(.) && . %in% 0:1)
TF_ish <- quote(TF || ZERO_OR_ONE)
vet(TF_ish, 1)
vet(TF_ish, "0")
```

You can also provide more helpful error messages with `mk_val_token` for
specific tokens:

```{r}
NONA <- mk_val_token(!is.na(.), "not contain NAs")
TF <- quote(logical(1L) && NONA)
vet(TF, NA)
```

See `?mk_val_token` for more details.

### Validation Expression Parsing and Evaluation Rules

Hopefully you were able to get an intuitive sense of how validation expressions work.  If you are interested in the actual rules, read on, otherwise skip to the next section.

After parsing the validation expression, `validate` examines each token for the presence of `.` or `.()`.  If either are present then the `.` values are substituted for the corresponding variable name (`current` for `validate`, and whatever variable is matched to the validation expression for `validate_args`).  Then each token is evaluted in the parent frame.  If the token evaluated was a custom expression then it is checked for truth.  If not, the result of evaluating the token is used as a template for an `alike` check against the object being tested, except for the special case when the template evaluates to a quoted language object.  In that case `validate` recursively applies the same logic to the language object as described above.

AUTHNOTE: more details on which exact parent frame is used.

### Predefined Tokens

`validate` comes with many predifined validation tokens for common cases:

```{r}
vet(NUM.1.POS, 5)
vet(NUM.1.POS, -3)
vet(NUM.1.POS, runif(5))
vet(CHR, letters)
vet(CHR, factor(letters))
```

See `?validation_tokens` for more details about what predefined tokens are available.

### S4 Classes

The natural solution to enforcing structural requirements in R objects is to use S4 classes.  Unfortunately S3 objects are so prevalent in R that a "backwards compatible" mechanism for enforcing structure requirement is warranted.

## Performance Considerations

### Benchmarks

Both `validate` and `alike` are written primarily in C to minimize the performance impact of adding validation checks to your functions.  Performance is comparable to or faster better than using `stopifnot`.  Here we run our checks on valid "laps" objects we used to illustrate [validation with complex S3 objects](#complex-s3-objects):

```{r}
library(microbenchmark)
microbenchmark(
  analyze2(laps.4), # stopifnot version
  analyze(laps.4)   # validate version
)
```

Performance is optimized for the success case.  Failure cases should still perform reasonably well, but will be slower than most success cases.

### Templates and Performance

Complex templates will be slower to evalute than simple ones, particularly for lists with lots of nested elements since `alike` recurses through all template list elements.

We recommend that you predefine templates in your package and not in the validation expression since some seemingly innocuous template creation expressions carry substantial overhead:

```{r}
microbenchmark(data.frame(a=numeric()))
```

This is slower than the entire validation process show in our prior examples.

## Acknowledgements

Thanks to [smbache](https://github.com/smbache) for some ideas I borrowed from his package [ensurer](https://github.com/smbache/ensurer), in particular for providing a function to validate objects other than function arguments.  Thanks also to Hadley Wickham for pointing me to smbache when I asked him about object validation.
