---
title: "vetR - Keep the Garbage Out"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, hilang='r')
options(width=60)
library(vetr)
```

```{r child='./rmdhunks/trust-but-verify.Rmd'}
```

```{r child='./rmdhunks/declarative-checks.Rmd'}
```

```{r child='./rmdhunks/vetting-expressions.Rmd'}
```

## Non Standard Evaluation of Vetting Expressions

### Parsing Vetting Expressions

Vetting expressions combine templates and custom tokens delimited by `&&` and
`||`. While superficially vetting expressions look like R expressions, they
are never run through the R evaluator.  Instead, they are recursively
substituted and parsed into tokens.  Each token is then examined to determine
whether it should be treated as a template token or a custom token.  For
example:

```{r, eval=FALSE}
logical(1) || (numeric(1) && . %in% 0:1)
```

is parsed as three tokens: `logical(1)`, `numeric(1)`, and `. %in% 0:1`.  Tokens
that contain `.` are interpreted as custom tokens, and tokens that do not
are treated as template tokens.  In this case the first two tokens are
considered templates, and the last is a custom expression, so the overall
vetting expression will accept scalar logicals, or 0 or 1:

```{r}
vet(logical(1) || (numeric(1) && . %in% 0:1), TRUE)
vet(logical(1) || (numeric(1) && . %in% 0:1), 0)
vet(logical(1) || (numeric(1) && . %in% 0:1), "1")
```

If you need to reference a literal dot (`.`) in a template, you can escape it by
adding another dot so that `.` becomes `..`.  If you want to reference `...`
you'll need to use `....`.  If you have a vetting expression that does not
reference the vetting object (i.e. does not use `.`) you can mark it as a
vetting expression by wrapping it in `.()` (if you want to use a literal
`.()` you can use `..()`).

If you need `&&` or `||` to be interpreted literally you can wrap the call in
`I` to tell `vet` not to recursively parse the expression:

```{r, eval=FALSE}
I(length(a) == length(b) && . %in% 0:1)
```

which will be treated as a single custom token.  `vet` will not recurse into
calls other than to `(`, `&&`, and `||`.  The use of `I` here is just an example
of this behavior and convenient since `I` does not change the meaning of the
vetting token.  An implication of this is you should not nest template tokens
inside functions as `vet` will not identify them as templates and you may get
unexpected results.  For example:

```{r, eval=FALSE}
I(logical(1L) && my_special_fun(.))
```

will always fail because `logical(1L)` is interpreted as `FALSE` rather than as
a template token for a scalar logical.

### Pre-defining Vetting Tokens

Vetting expressions are language objects.  Normally the language object is
captured via substitution from the `vet` argument, but you can also store language to variables and use that with `vet`:

```{r}
TF <- quote(logical(1) && !anyNA(.))  # note `quote`

vet(TF, TRUE)
vet(TF, NA)
vet(TF, 1)
```

Since `vetr` parses and evaluates tokens recursively, you can even combine
pre-stored tokens:

```{r}
ZERO_OR_ONE <- quote(numeric(1) && !is.na(.) && . %in% 0:1)
TF_ish <- quote(TF || ZERO_OR_ONE)

vet(TF_ish, 1)
vet(TF_ish, "0")
```

You can also provide more helpful error messages with `vet_token` for
specific tokens:

```{r}
NONA <- vet_token(!is.na(.), "%sshould not contain NAs")
TF <- quote(logical(1L) && NONA)
vet(TF, NA)
```

See `?vet_token` for more details.

### Vetting Expression Parsing and Evaluation Rules

Hopefully you were able to get an intuitive sense of how vetting expressions
work.  If you are interested in the actual rules, read on, otherwise skip to the
next section.

After parsing the vetting expression, `vet` examines each token for the presence
of `.` or `.()`.  If either are present then the `.` values are substituted for
the corresponding variable name (`current` for `vet`, and whatever variable
is matched to the vetting expression for `vetr`).  Then each token
is evaluted in the parent frame.  If the token evaluated was a custom expression
then it is checked for truth.  If not, the result of evaluating the token is
used as a template for an `alike` check against the object being tested, except
for the special case when the template evaluates to a language object.  In that
case `vet` recursively applies the same logic to the language object as
described above.

Some care is required when using language objects themselves as templates.  For
example, suppose we want our template to be a call to `&&`, then we must quote
it:

```{r}
vet(quote(x && y), quote(a || b))
vet(quote(x && y), quote(a && b))
```

Since `quote` is not a call to `(`, `&&`, or `||` it is evaluated and the
resulting language object is used as a template token.  Once a token is
evaluated it is no longer recursively substituted and parsed, which is why `x`
and `y` are not each treated as tokens themselves.  If we want to store
the vetting expression in a variable then we must double quote:

```{r}
LANG.AND <- quote(quote(x && y))
vet(LANG.AND, quote(a || b))
vet(LANG.AND, quote(a && b))
```

For more details on language templates see the [alike vignette](alike.html).

### Predefined Tokens

`vetr` comes with many predefined vetting tokens for common cases:

```{r}
vet(NUM.1.POS, 5)
vet(NUM.1.POS, -3)
vet(NUM.1.POS, runif(5))
vet(CHR, letters)
vet(CHR, factor(letters))
```

See `?vet_token` for more details about what predefined tokens are available.

## Function Arguments

The `vetr` function streamlines parameter checks in functions.  It behaves just
like `vet`, except that you need only specify the vetting expressions.  The
objects to vet are captured from the function environment:

```{r}
fun <- function(x, y, z) {
  vetr(
    matrix(numeric(), ncol=3),
    logical(1L),
    character(1L) && . %in% c("foo", "bar")
  )
  TRUE  # do work...
}
fun(matrix(1:12, 3), TRUE, "baz")
fun(matrix(1:12, 4), TRUE, "baz")
fun(matrix(1:12, 4), TRUE, "foo")
```

The arguments to `vetr` are matched to the arguments of the enclosing function
in the same way as with `match.call`.  For example, if we wished to vet just
the third argument:

```{r}
fun <- function(x, y, z) {
  vetr(z=character(1L) && . %in% c("foo", "bar"))
  TRUE  # do work...
}
fun(matrix(1:12, 3), TRUE, "baz")
fun(matrix(1:12, 4), TRUE, "bar")
```

Vetting expressions work the same way with `vetr` as they do with `vet`.

## Performance Considerations

### Benchmarks

`vetr` is written primarily in C to minimize the performance impact of adding
validation checks to your functions.  Performance is comparable to or faster
better than using `stopifnot`.  Here we run our checks on valid "laps" objects
we used to illustrate [vet with complex S3 objects](#complex-s3-objects):

```{r}
library(microbenchmark)
microbenchmark(
  vet(laps.template, laps2),
  vet_stopifnot(laps2)
)
```

Performance is optimized for the success case.  Failure cases should still
perform reasonably well, but will be slower than most success cases.

### Templates and Performance

Complex templates will be slower to evaluate than simple ones, particularly for
lists with lots of nested elements.  Note however that the cost of the vetting
expression is a function of the complexity of the template, not that of the
value being vetted.

We recommend that you predefine templates in your package and not in the
validation expression since some seemingly innocuous template creation
expressions carry substantial overhead:

```{r}
microbenchmark(data.frame(a=numeric()))
```

In this case the `data.frame` call alone take over 100us.

## Alternatives

### `stopifnot`

`stopifnot` is a fine solution in many cases, but the error messages that result
from it can be cryptic, and it can take a fair bit of effort to set-up
comprehensive tests for complex objects.

### S4 Classes

The natural solution to enforcing structural requirements in R objects is to use
S4 classes.  Unfortunately S3 objects are so prevalent in R that a "backwards
compatible" mechanism for enforcing structure requirement is warranted.

### Valaddin

[valaddin](https://github.com/egnha/valaddin) is a great package by [Eugene
Ha](https://github.com/egnha).  Both `valaddin` and `vetr` are primarily
intended for function input vetting.

`valaddin` works by modifying function objects, which makes it easy to add
validation to existing functions in the workspace or functions from packages you
do not control.  The interface is very flexible and allows you to specify pretty
much any vetting requirement you wish.

`vetr` requires you to modify the source of a function or to explicitly wrap a
function in another.  `vetr` does have some advantages though:

* Declarative template based vetting
* Auto-composition of helpful error messages
* Minimal computational overhead

Here we borrow an example from the `valaddin` vignette to illustrate the
last point:

```{r}
library(valaddin)

secant <- function(f, x, dx) (f(x + dx) - f(x)) / dx

secant_valaddin <- valaddin::firmly(secant, list(~x, ~dx) ~ is.numeric)
secant_stopifnot <- function(f, x, dx) {
  stopifnot(is.numeric(x), is.numeric(dx))
  secant(f, x, dx)
}
secant_vetr <- function(f, x, dx) {
  vetr(x=numeric(), dx=numeric())
  secant(f, x, dx)
}

microbenchmark(
  secant_valaddin(log, 1, .1),
  secant_stopifnot(log, 1, .1),
  secant_vetr(log, 1, .1)
)
```

In many cases ~100us is not enough of a difference to be concerned with, but
if an R function must be applied repeatedly (e.g. split-apply-combine analysis
with many groups) then it becomes meaningful.

### Other Third Party Packages

* [ensurer](https://github.com/smbache/ensurer)
* [types](https://github.com/jimhester/types)
* [argufy](https://github.com/gaborcsardi/argufy)

## Acknowledgements

Thanks to [smbache](https://github.com/smbache) for some ideas I borrowed from
his package [ensurer](https://github.com/smbache/ensurer), in particular for
providing a function to vet objects other than function arguments.  Thanks
also to Hadley Wickham for pointing me to smbache when I asked him about object
vetting.
