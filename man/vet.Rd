% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/validate.R
\name{vet}
\alias{vet}
\alias{vetr}
\alias{tev}
\alias{vet}
\title{Vet Objects and Function Arguments}
\usage{
vetr(...)

vet(target, current, format = "text", stop = FALSE)
}
\arguments{
\item{...}{arguments to vetr; they will be matched to the enclosing
function formals as with \code{\link{match.call}}}

\item{target}{a template, a vetting expression, or a compound expression}

\item{current}{an object to vet}

\item{format}{character(1L), controls the format of the return value for
  \code{vet}, in case of failure.  One of:\itemize{
    \item "text": (default) character(1L) message for use elsewhere in code
    \item "full": character(1L) the full error message used in "stop" mode,
      but actually returned instead of thrown as an error
    \item "raw": character(N) least processed version of the error message
      with none of the formatting or surrounding verbiage
}}

\item{stop}{TRUE or FALSE whether to call \code{\link{stop}} on failure
(default) or not}
}
\value{
TRUE if validation succeeds, otherwise \code{stop} for
  \code{vetr} and varies for \code{vet} according to value chosen with
  parameter \code{stop}
}
\description{
Use templates and expressions to vet objects or function arguments.
\code{vet} vets objects, and \code{vetr} vets the formals of the
function that encloses it.
}
\details{
The \code{target} argument for \code{vet} and the \code{...} arguments are
recursively substituted.  If you wish to programmatically specify a vetting
expression you can provide it as quoted language.

See \code{vignette('vetr', package='vetr')} and examples for details on how
to use these functions.
}
\note{
\code{vetr} will force evaluation of any arguments that are being
  checked (you may omit arguments that should not be evaluate from
  \code{vetr})
}
\examples{
## template vetting
vet(numeric(2L), runif(2))
vet(numeric(2L), runif(3))
vet(numeric(2L), letters)
try(vet(numeric(2L), letters, stop=TRUE))

## Zero length templates are wild cards
vet(numeric(), runif(2))
vet(numeric(), runif(100))
vet(numeric(), letters)

## This extends to data.frames
iris.tpl <- iris[0,]   # zero row
iris.1 <- iris[1:10,]
iris.2 <- iris[1:10, c(1,2,3,5,4)]  # change col order
vet(iris.tpl, iris.1)
vet(iris.tpl, iris.2)

## Short (<100 length) integer-like numerics will
## pass for integer
vet(integer(), c(1, 2, 3))
vet(integer(), c(1, 2, 3) + 0.1)

## Nested templates; note, in packages you should consider
## defining templates outside of `vet` or `vetr` so that
## they are computed on load rather that at runtime
tpl <- list(numeric(1L), matrix(integer(), 3))
val.1 <- list(runif(1), rbind(1:10, 1:10, 1:10))
val.2 <- list(runif(1), cbind(1:10, 1:10, 1:10))
vet(tpl, val.1)
vet(tpl, val.2)

## Vetting expression
vet(. > 0, runif(10))
vet(. > 0, -runif(10))

## Compound expressions (template(s) + expression(s)):
vet(numeric(2L) && . > 0, runif(2))
vet(numeric(2L) && . > 0, runif(10))
vet(numeric(2L) && . > 0, -runif(2))

## Using pre-defined tokens (see `?vet_token`)
vet(INT.1, 1)
vet(INT.1, 1:2)
vet(INT.1 && . \%in\% 0:1 || LGL.1, TRUE)
vet(INT.1 && . \%in\% 0:1 || LGL.1, 1)
vet(INT.1 && . \%in\% 0:1 || LGL.1, NA)

## Function parameter vetting
fun1 <- function(x, y) {
  vetr(integer(), LGL.1)
  TRUE   # do some work
}
fun1(1:10, TRUE)
try(fun1(1:10, 1:10))

## only vet the second argument
fun2 <- function(x, y) {
  vetr(y=LGL.1)
  TRUE   # do some work
}
try(fun2(letters, 1:10))

## more complex vetting (`tpl`, `val.1`, and `val.2` defined in
## earlier examples)
fun3 <- function(x, y) {
  vetr(x=tpl, y=tpl && ncol(.[[2]]) == ncol(x[[2]]))
  TRUE   # do some work
}
fun3(val.1, val.1)
try(fun3(val.1, val.2))
val.1.a <- val.1
val.1.a[[2]] <- val.1.a[[2]][, 1:8]
try(fun3(val.1, val.1.a))
}
\seealso{
\code{\link{alike}} for how templates are used,
  \code{\link{vet_token}} for how to specify custom error messages and also
  for predefined validation tokens for common use cases.
}
