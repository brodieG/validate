---
title: "Parameter Validation Functions"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: ../vignettes/styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE)
library(vetr)
library(assertive)
library(assertthat)
library(ensurer)
library(checkmate)
library(valaddin)
```

## Prevent Garbage In

Most functions expect their parameters to be of specific types, structures, or
values.  If we allow functions to operate on parameters that do not conform to
the expectations then we could get in the best case difficult to debug errors
from the bowels of the function, and in the worst silent undefined behavior.

Systematically vetting function parameters is as tedious as it is important, but
fortunately many packages exist to assist with the process.  We will review
those packages and assess them across these dimensions:

* Ease of use for the function developer incorporating parameter checks
* Computing overhead
* Ease of use for end users

We will review the following packages / functions:

* `stopifnot` by R Core, evaluates test expressions and `stops` if they return
  anything other than all TRUE vectors.
* [`vetr`](https://github.com/brodieG/vetr) by Yours Truly, augments test
  expressions with templates for object structure verification.  This allows for
  a succinct and extensible declarative syntax.  The package also emphasizes
  informative error messages and speed.
* [`asserthat`](https://github.com/hadley/assertthat) by Hadley Wickham, a
  drop-in replacement for `stopifnot` with more helpful error messages for
  checks based on the base `is.*` functions (e.g. `is.character`) and some
  additional helper functions for common checks.
* [`assertive`](https://www.r-pkg.org/pkg/assertive) by Richie Cotton, a
  large library of checking functions for most common parameter checks with
  expressive error messages.
* [`checkmate`](https://github.com/mllg/checkmate) by Michael Lang, a library of
  flexible checking functions for most common types of objects, with an emphasis
  on speed and conciseness, particularly for vectors.
* [`ensurer`](https://github.com/smbache/ensurer) by Stefan M. Bache, a
  framework for constructing re-usable and extensible check contracts, with a
  flexible reporting channel, a mechanism for applying check contracts to
  function _outputs_, and an experimental interface for embedding the checking
  contracts into functions.

Not all of these packages are specifically designed to test function parameters,
but they can all be used that way.  We will also focus on "out of the box"
functionality.  For example, most of these packages support custom user supplied
error messages, but we evaluate only the error messages produced without
additional user intervention.  We also ignore functionality that is not
specifically used for function parameter checking.

The following packages also perform related tasks, although we do not review
them here:

* [`valaddin`](https://github.com/egnha/valaddin) by Eugene Ha, a framework for
  augmenting existing functions with validation contracts.  Currently the
  package is undergoing a major overhaul so we will add it to the comparison
  once the new release (v0.3.0) is out.
* [`validate`](https://github.com/data-cleaning/validate) by Mark van
  der Loo and Edwin de Jonge, with a primary focus on validating data in data
  frames and similar data structures
* [`assertr`](https://github.com/ropensci/assertr) by Tony Fischetti, also
  focused on data validation in data frames and similar structures
* [`types`](https://github.com/jimhester/types) by Jim Hester, which implements
  but does not enforce type hinting
* [`argufy`](https://github.com/gaborcsardi/argufy) by Gábor Csárdi, which
  implements parameter validation via roxygen tags (not released to CRAN)

## Summary

Every package is compared to `stopifnot` across several dimensions.  The only
objective measurements here are the timings  Everything else is my opinion
which you can safely assume is biased in favor of my own package `vetr`.

<table>
<col width='50px'><col width='300px'><col width='300px'>
<tr>
  <th>&nbsp;
  <th>Pros
  <th>Cons

<tr>
<th>stopifnot
<td>
  <ul>
  <li>No learning curve
  <li>Fast
  <li>Part of base
  </ul>
<td>
  <ul>
  <li>Comprehensive parameter checking is tedious
  <li>Error messages can seem cryptic
  </ul>
<tr>
<th>asserthat
<td>
  <ul>
  <li>No learning curve
  <li>Better error messages for basic `is.*` checks
  <li>A few helpful additional `is.*` functions for common checks
  </ul>
<td>
  <ul>
  <li>Comprehensive parameter checking is tedious
  <li>Fast, but slower than `stopifnot`
  </ul>
<tr>
<th>assertive
<td>
  <ul>
  <li>Custom check functions for most situations
  <li>Excellent error reporting
  </ul>
<td>
  <ul>
  <li>Slowest of the group, by far
  <li>Hundreds of functions
<tr>
<th>checkmate
<td>
  <ul>
  <li>Custom check functions for most situations
  <li>Fast, particularly for vectors
  <li>Improved error reporting
  </ul>
<td>
  <ul>
  <li>Dozens of reasonably complex functions
  </ul>
<tr>
<th>ensurer
<td>
  <ul>
  <li>Easily extensible checking framework
  <li>Easily customizable failure conditions
  </ul>
<td>
  <ul>
  <li>Fairly slow
  <li>New concepts
  </ul>
<tr>
<th>vetr
<td>
  <ul>
  <li>Intuitive and concise declarative object structure checks
  <li>Fast, particularly for complex objects and large vectors
  <li>Trivially extensible vetting expressions
  <li>Emphasis on useful error reporting
  </ul>
<td>
  <ul>
  <li>New concepts
  <li>Still in development, although interface should be mostly stable.
  </ul>
</table>

`asserthat` is the package that makes fewest trade-offs relative to `stopifnot`.
However the improvements it makes are modest.

`assertive` and `checkmate` improve on `stopifnot` by packaging a
broad range of common checks into a function library (a very large library for
`assertive`, or a modest one with complex functions for `checkmate`).  This adds
a learning curve, and in the case of `assertive` a lot of computation overhead.

`ensurer` and `vetr` improve on `stopifnot` by introducing new validation
concepts.  This also adds to the learning curve, and in the case of `ensurer`
adds a bit of computation overhead.

```{r list_funs, echo=FALSE}
list_funs <- function(pkg) {
  space <- sprintf("package:%s", pkg)
  object.names <- ls(space)
  objects <- mget(object.names, envir=as.environment(space))
  names(objects)[sapply(objects, is.function)]
}
count_funs <- function(pkgs) {
  fun.list <- lapply(pkgs, list_funs)
  lens <- lengths(fun.list)
  names(lens) <- sprintf(
    "`%s (v%s)`", pkgs, as.character(lapply(pkgs, packageVersion))
  )
  lens
}
```
```{r}
count_funs(c('vetr', 'assertthat', 'ensurer', 'assertive', 'checkmate'))
```

## Developer Experience

### A Function With Simple Parameters

**DEVNOTE: do we really need this section?  Maybe simplify it to one or two
params?  Originally we wanted 3 to get a more realistic view of the overhead
since single parameter functions are pretty rare and that view is particularly
unfavorable to `vetr` due to the `match.call` overhead.**

We want to write a function that accepts a numeric vector as the first
argument, and TRUE or FALSE as the second.check the following three parameter function:

```{r, eval=FALSE}
function(
  num,     # numeric vector
  opt,     # scalar character in c("one", "two", "three")
  flag     # TRUE or FALSE
)
```
```{r}
valid.opts <- c("one", "two", "three")   # values valid in `opts`
```

We start with `stopifnot`, since it is the simplest and most well known option:

```{r}
f1_stopifnot <- function(num, opt, flag) {
  stopifnot(
    is.numeric(num),
    isTRUE(opt %in% valid.opts),
    length(flag) == 1 && !is.na(flag) && is.logical(flag)
  )
}
```

`asserthat` is most similar to `stopifnot`:

```{r}
f1_assertthat <- function(num, opt, flag) {
  assert_that(
    is.numeric(num),
    opt %in% valid.opts,          # `isTRUE` not necessary
    is.flag(flag) && !is.na(flag) # adds the `is.flag` function
  )
}
```

The `vetr` implementation is also similar to `stopifnot`, except we can use
templates and `.` as shorthand for the matched parameter:

```{r}
f1_vetr <- function(num, opt, flag) {
  vetr(
    numeric(),                 # template
    isTRUE(. %in% valid.opts), # custom token (contains `.`)
    logical(1L) && !is.na(.)   # template && custom token
  )
}
```

`vetr` matches the arguments of the enclosing function and checks them against
vetting tokens.  Vetting tokens can be combined with `&&`/`||`.  For example,
`logical(1L) && !is.na(.)` are two vetting tokens.  Vetting tokens that contain
`.` substitute the `.` for the parameter and are tested for truth as `stopifnot`
does.  The other tokens are treated as templates that the matching parameter
must conform to.

`ensurer` takes a similar approach, although requires a separate call to
`ensure` for each argument:

```{r}
f1_ensurer <- function(num, opt, flag) {
  ensure(num, is.numeric(.))
  ensure(opt, . %in% valid.opts)
  ensure(flag, length(.) == 1 && !is.na(.) && is.logical(.))
}
```

`checkmate` implements many custom assertion functions which results in
concise checks:

```{r}
f1_checkmate <- function(num, opt, flag) {
  assertNumeric(num)
  assertChoice(opt, valid.opts)
  assertFlag(flag)
}
```

`assertive` also implements many custom functions, although the intersection
between what we needed and what we could find was not as good as with
`checkmate`:

```{r}
f1_assertive <- function(num, opt, flag) {
  assert_is_numeric(num)
  assert_is_identical_to_true(opt %in% valid.opts)
  assert_is_a_bool(flag)
  assert_all_are_not_na(flag)
}
```

For this type of check it is not obvious that any of the packages do a much
better job than `stopifnot` from the perspective of the developer.  There are
however some noticeable differences when we actually run the functions with
illegal parameters:

```{r}
f1_stopifnot(letters, "two", TRUE)
f1_vetr(letters, "two", TRUE)
f1_assertthat(letters, "two", TRUE)
f1_assertive(letters, "two", TRUE)
f1_ensurer(letters, "two", TRUE)
f1_checkmate(letters, "two", TRUE)
```

`assertive`, `checkmate`, and `vetr` all tell you what the object is in addition
to what it should be.  Only `vetr` returns the actual failing call which matches
the semantics of calling `stop` within a function.  The other packages either do
not include the call, or include the top level call which is less useful.
Finally, only `vetr` uses the parameter expression as it appears in the calling
frame (i.e. `letters` instead of `num`).  This makes it easier to debug the
failure from the calling context.

### Building Compound Checks

If you wish to build re-usable complex checks with `stopifnot`  or `asserthat`
you would do so by writing functions:

```{r}
is.num_mx <- function(x) is.numeric(x) && is.matrix(x)
is.sqr <- function(x) ncol(x) == nrow(x)
is.sqr_num_mx <- function(x) is.num_mx(x) && is.sqr(x)

rect.mx <- matrix(1:12, 3)

f2_stopifnot <- function(x) {
  stopifnot(is.sqr_num_mx(x))
}
f2_stopifnot(rect.mx)
```

The main drawback from this approach is the somewhat uninformative error
message.

`vetr` is similar, except that you can combine templates and custom tokens as
language objects and retain the more granular error reporting:

```{r}
vetr.num.mx <- matrix(numeric(), 0)   # this is a template
vetr.sqr <- quote(ncol(.) == nrow(.)) # custom tokens must be quoted
vetr.sqr.mx <- quote(vetr.num.mx && vetr.sqr)

f2_vetr <- function(x) {
  vetr(vetr.sqr.mx)
}
f2_vetr(rect.mx)
```

`ensurer` generates and combines contracts with `ensures`, which also preserves the more granular error reporting:

```{r}
ensurer_num_mx <- ensures(is.numeric(.) && is.matrix(.))
ensurer_sqr <- ensures(ncol(.) == nrow(.))
ensurer_sqr_mx <- ensures(+ensurer_num_mx, +ensurer_sqr)

f2_ensurer <- function(x) {
  ensurer_sqr_mx(x)
}
f2_ensurer(rect.mx)
```

The `checkmate` and `assertive` can create assertions from arbitrary check
functions, but in both cases you end up losing details about the nature of the
failure:

```{r}
assertSquareNumMx <- makeAssertionFunction(is.sqr_num_mx)

f2_checkmate <- function(x) {
  assertSquareNumMx(x)
}
f2_checkmate(rect.mx)

f2_assertive <- function(x) {
  assert_engine(is.sqr_num_mx, x=x)
}
f2_assertive(rect.mx)
```

Note that for the last two the existing functions `checkMatrix` and
`assert_square_matrix` are available, but we omit using them to illustrate the
extension mechanism for those functions.

Outside of `stopifnot` every package has a mechanism for manually specifying
more informative error messages, but we do not explore those here.


```{r}
f3_stopifnot <- function(num) {
  stopifnot(is.numeric(num), !anyNA(num), all(num > 0))
}
f3_vetr <- function(num) {
  vetr(numeric() && all_bw(., 0, Inf,  bounds="(]"))
}
f3_assertthat <- function(num) {
  assert_that(is.numeric(num), !anyNA(num), all(num > 0))
}
f3_ensurer <- function(num) {
  ensure(num, is.numeric(.), !anyNA(num), all(num > 0))
}
f3_checkmate <- function(num) {
  qassert(num, "n*(0,]")
}
f3_assertive <- function(num) {
  assert_all_are_in_left_open_range(num, lower=0)
}
```

In this case

### Benchmarks

We benchmark the functions with `mb`, a thin wrapper around `microbenchmark`
(see the [appendix](#appendix) for its definition).  Note that the `mean`
numbers are likely skewed by outlier timings caused by `rmarkdown`.

```{r mb_define, echo=FALSE}
mb <- function(...) {
  mb.call <- match.call()
  mb.call[[1]] <- quote(microbenchmark::microbenchmark)

  mb.res <- summary(eval(mb.call, envir=parent.frame()))
  mb.res <- mb.res[order(mb.res$median), ]
  mb.res[, -1] <- lapply(
    mb.res[, -1], function(x) format(round(x), big.mark=",")
  )
  cat(
    sprintf("Unit: %s, neval: %s\n\n", attr(mb.res, 'unit'), mb.res$neval[1])
  )
  print(mb.res[, c('expr', 'lq', 'median', 'uq', 'mean')], quote=FALSE)
}
```
```{r, echo=FALSE}
mb(
  f1_assertive(pi, "three", TRUE),
  f1_assertthat(pi, "three", TRUE),
  f1_ensurer(pi, "three", TRUE),
  f1_checkmate(pi, "three", TRUE),
  f1_stopifnot(pi, "three", TRUE),
  f1_valaddin(pi, "three", TRUE),
  f1_vetr(pi, "three", TRUE)
)
```

`stopifnot` leads the way, which is not surprising given the simplicity of the
checks involved.  `checkmate` is second, although both `vetr` and `asserthat`
are in the same neighborhood.  Performance drops off substantially after
`asserthat`.

One could argue that the performance differences here are trivial.  After all,
even the slowest approach clocks in under 3 milliseconds.  However, given the
prevalence of split-apply-combine style analysis, where a single function could
be applied to thousands or even millions of data groups, the performance
differences shown here can have a substantial impact on overall computation
time.

## Strictly Positive

```{r}
str.pos.vec <- runif(5e4) + 1  # test with a 50K long vector
```
```{r, echo=FALSE}
mb(times=10,
  f3_assertive(str.pos.vec),
  f3_assertthat(str.pos.vec),
  f3_ensurer(str.pos.vec),
  f3_checkmate(str.pos.vec),
  f3_stopifnot(str.pos.vec),
  f3_valaddin(str.pos.vec),
  f3_vetr(str.pos.vec)
)
```

`vetr` is now the fastest option, although this is primarily because we use
`vetr::all_bw` instead of the equivalent `!anyNA(.) && all(. > 0)` expression.
`all_bw` is implemented in C and avoids the intermediate vectors required to
evaluate the standard R version.  `checkmate` does the same with `qassert`.
Notice also that for both `vetr` and `checkmate` the mean and median timings are
close.  This is likely because these functions do not require the
occasional expensive garbage collections caused by intermediate vectors.

## A Complex Object

Here we wish to verify that an input conforms to the structure of the `iris`
built-in data set.

```{r}
iris.tpl <- vetr::abstract(iris) # equivalently: iris[0, ]
iris.fake <- iris
levels(iris.fake$Species)[3] <- "sibirica"   # tweak levels
```
We will narrow the field to `vetr`, `stopifnot`, and `checkmate` primarily
```{r}
f4_vetr <- function(x) {
  vetr(iris.tpl)
}
f4_vetr(iris.fake)

f4_stopifnot <- function(x) {
  stopifnot(
    is.list(x), inherits(x, "data.frame"),
    length(x) == 5, is.integer(attr(x, 'row.names')),
    identical(names(x), names(iris.tpl)),
    typeof(x$Species) == "integer", is.factor(x$Species),
    identical(levels(x$Species), levels(iris.tpl$Species))
  )
}
f4_stopifnot(iris.fake)

f4_checkmate <- function(x) {
  assertDataFrame(
    x, types=c("numeric", "numeric", "numeric", "numeric", "factor")
  )
  assertNames(names(x), identical.to=names(iris.tpl))
  assertFactor(x$Species, levels=levels(iris.tpl$Species))
}
f4_checkmate(iris.fake)
```

This is where the power of the template becomes apparent.  Rather than
painstakingly generating a list of all the comparisons required to validate the
object, we point to an existing object to use as a template. `vetr` recursively
traverses the template and the function parameter in parallel, ensuring that the
structure of the template elements is matched by those of the parameter
elements.  Even if an existing object does not exist, it is easier to manually
construct such a template than to specify all the function calls required to
confirm conformance to the template structure.

In addition to the compact representation, notice the error message:

> `levels(iris.fake$Species)[3]` should be "virginica" (is "sibirica")

This is by far the most useful of the three as it highlights the exact location
of the failure in a form you can immediately copy-paste into your prompt for
further examination.

Additionally, since all the `vetr` comparisons are done internally in C, `vetr`
is the fastest option:

```{r, echo=FALSE}
mb(
  f4_vetr(iris),
  f4_stopifnot(iris),
  f4_checkmate(iris)
)
```

## Comparison Dimensions

* Error message
  * Reports call like stop
  * Explains what it is not
  * Uses language from calling scope
  * Explains what it is
* Style (wrapper / function)
* Median timings
    * Simple tests
    * Values
    * Data frame
    * S3 Object
* Compound expressions

### Or Checks

## Comparison

## Appendix

```{r list_funs}
```

```{r mb_define}
```

