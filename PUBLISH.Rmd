---
title: "vetR - Trust, but Verify"
output:
    rmarkdown::html_vignette:
        toc: true
        css: vignettes/styles.css
---

```{r, echo=FALSE}
knitr::opts_chunk$set(error=TRUE)
library(vetr)
```

## Tweet #1

Declarative structural guarantees for #rstats S3 objects via templates with new
pkg #vetr https://github.com/brodieG/vetr (1/4)

### Like vapply

Declarative checks via templates, much like `vapply`:

```{r}
vet(numeric(1L), 1:3)
vet(numeric(1L), "hello")
vet(numeric(1L), 42)
```

### Handles Complex Objects

```{r}
vet(matrix(integer(), ncol=3), matrix(1:12, 4))
vet(matrix(integer(), ncol=3), matrix(1:12, 3))
```

Even recursive ones:

```{r}
iris.template <- abstract(iris)
iris.fake <- iris
levels(iris.fake$Species)[3] <- 'Sibirica'
```
```{r}
vet(iris.template, iris[1:10,])
vet(iris.template, iris.fake[1:10, ])
```

while *auto-generating useful* error messages.

## Tweet #2

We made `vetr` fast to mitigate overhead concerns. There is a
dedicated mode for fun param vetting (2/4)

### Fast

Comparable in performance to `stopifnot` for simple checks, and faster for
complex ones:

```{r}
mx.3.col.num <- matrix(numeric(), ncol=3)
mx1 <- matrix(1:12, 4)

bench_mark(times=1e4,
  vet(mx.3.col.num, mx1),
  stopifnot(is.matrix(mx1), is.numeric(mx1), ncol(mx1) == 3)
)
```

### In Functions

`vetr()` streamlines function parameter vetting:

```{r}
fun <- function(x, y) {
  vetr(integer(), character(1L) || NULL)
}
fun(1, 'hello')
fun(1, NULL)
fun(1, 2)
```

## Tweet #3

Create complex vetting expressions with programmable non-standard-evaluation
(3/4)

### Programmable NSE

You can create complex vetting expressions from simple ones:

```{r}
a <- quote(integer() && . > 0)
b <- quote(logical(1L) && !is.na(.))
```
```{r}
vet(a || b, 1:3)
vet(a || b, -(1:3))
```
```{r}
c <- quote(a || b)  # equivalently
```
```{r}
vet(c, -(1:3))
```

## Tweet #4

On CRAN, 100% coverage with #covr https://github.com/jimhester/covr 
and #unitizer https://github.com/brodieG/unitizer, but under dev so feedback
welcome (4/4)


