<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Brodie Gaslam" />

<meta name="date" content="2018-03-27" />

<title>Parameter Validation Mechanisms in R</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



<style type="text/css">
body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.5;
}
#header {
text-align: center;
}
#TOC {
clear: both;

padding: 4px;
width: 100%;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 1em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
h3.subtitle {
margin-top: -23px;
}
pre, code {
background-color: #EEE;
color: #333;
white-space: pre-wrap; 

}
code {font-size: 85%;}
pre {
border: 2px solid #EEE;
overflow: auto;

margin: 5px 0px;
padding: 5px 10px;
}
pre:not([class]) {
color: #353;

}
div.sourceCode pre, div.sourceCode code {
background-color: #FAFAFA;
}
div.sourceCode pre{

}
div.sourceCode + pre,
div.sourceCode + div.diffobj_container {
margin-top: -5px;
}
div.diffobj_container pre{
line-height: 1.3;
}

code {
font-family: Consolas, Monaco, 'Courier New', monospace;
}
p > code, li > code, h1 > code, h2 > code, h3 > code,
h4 > code, h5 > code, h6 > code {
padding: 2px 0px;
line-height: 1;
font-weight: bold;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
padding-bottom: 3px;
font-size: 35px;
line-height: 40px;
border-bottom: 1px solid #999;
}
h2 {
border-bottom: 1px solid #999;
padding-top: 5px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
padding-top: 5px;
font-size: 120%;
}
h4 {

color: #777;
font-size: 105%;
}
h4.author {display: none;}
h4.date {margin-top: -20px;}
h5, h6 {

font-size: 105%;
}
a {
color: #2255dd;
font-weight: bold;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #555; } 
code > span.fl { color: #555; } 
code > span.ch { color: #555; } 
code > span.st { color: #40a070; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>

</head>

<body>




<h1 class="title toc-ignore">Parameter Validation Mechanisms in R</h1>
<h4 class="author"><em>Brodie Gaslam</em></h4>
<h4 class="date"><em>2018-03-27</em></h4>


<div id="TOC">
<ul>
<li><a href="#overview">Overview</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#simple">Simple</a></li>
<li><a href="#concise">Concise</a></li>
<li><a href="#informative">Informative</a></li>
<li><a href="#fast">Fast</a></li>
</ul></li>
<li><a href="#comparison-details">Comparison Details</a><ul>
<li><a href="#simple-parameters">Simple Parameters</a></li>
<li><a href="#complex-objects">Complex Objects</a></li>
<li><a href="#vector-values">Vector Values</a></li>
<li><a href="#compound-checks">Compound Checks</a></li>
</ul></li>
<li><a href="#benchmarks">Benchmarks</a><ul>
<li><a href="#detail-benchmarks">Detail Benchmarks</a></li>
<li><a href="#making-vetr-faster">Making <code>vetr</code> Faster</a></li>
</ul></li>
<li><a href="#conclusions">Conclusions</a></li>
<li><a href="#appendix">Appendix</a><ul>
<li><a href="#definitions">Definitions</a></li>
<li><a href="#references">References</a></li>
<li><a href="#ancillary-code">Ancillary Code</a></li>
<li><a href="#session-info">Session Info</a></li>
<li><a href="#end-notes">End Notes</a></li>
</ul></li>
</ul>
</div>

<p><a name="overview"></a></p>
<div id="overview" class="section level2">
<h2>Overview</h2>
<div style="font-size: .8em; margin-top: -12px;">
<div class="line-block"><a href="#top">Top</a> | <a href="#overview">Overview</a> | <a href="#details">Details</a> | <a href="#benchmarks">Benchmarks</a> | <a href="#appendix">Appendix</a></div>
</div>
<div id="introduction" class="section level3">
<h3>Introduction</h3>
<p>Systematically vetting function parameters is as tedious as it is important. Fortunately many functions and packages exist to assist with the process. We will review:</p>
<ul>
<li><code>stopifnot</code> by R Core</li>
<li><a href="https://github.com/brodieG/vetr"><code>vetr</code></a> by Yours Truly</li>
<li><a href="https://github.com/hadley/assertthat"><code>asserthat</code></a> by Hadley Wickham</li>
<li><a href="https://www.r-pkg.org/pkg/assertive"><code>assertive</code></a> by Richie Cotton</li>
<li><a href="https://github.com/mllg/checkmate"><code>checkmate</code></a> by Michel Lang</li>
</ul>
<p>The following packages also perform related tasks, although we do not review them:</p>
<ul>
<li><a href="https://github.com/egnha/valaddin"><code>valaddin</code></a> v0.1.0 by Eugene Ha, a framework for augmenting existing functions with validation contracts. Currently the package is undergoing a major overhaul so we will add it to the comparison once the new release (v0.3.0) is out.</li>
<li><a href="https://github.com/smbache/ensurer"><code>ensurer</code></a> v1.1 by Stefan M. Bache, a framework for flexibly creating and combining validation contracts. The development version adds an experimental method for creating type safe functions, but it is not published to CRAN so we do not test it here.</li>
<li><a href="https://github.com/data-cleaning/validate"><code>validate</code></a> by Mark van der Loo and Edwin de Jonge, with a primary focus on validating data in data frames and similar data structures.</li>
<li><a href="https://github.com/ropensci/assertr"><code>assertr</code></a> by Tony Fischetti, also focused on data validation in data frames and similar structures.</li>
<li><a href="https://github.com/jimhester/types"><code>types</code></a> by Jim Hester, which implements but does not enforce type hinting.</li>
<li><a href="https://github.com/gaborcsardi/argufy"><code>argufy</code></a> by Gábor Csárdi, which implements parameter validation via roxygen tags (not released to CRAN).</li>
</ul>
</div>
<div id="summary" class="section level3">
<h3>Summary</h3>
<p>We compare several packages to <code>stopifnot</code> for the task of checking function parameters. We ignore all other features. The following table summarizes the strengths of each package:</p>
<table>
<col>
<col width="100px">
<col width="100px">
<col width="100px">
<col width="100px">
<thead>
<tr>
<th>
<th>
assertthat
<th>
assertive
<th>
checkmate
<th>
vetr
<tbody style="text-align: center;">
<tr>
<td style="text-align:left;">
Simple
<td>
<span style="color: green;">✓</span>
<td>
<td>
<td>
<tr>
<td style="text-align:left;">
Concise
<td>
<td>
<td>
<span style="color: green;">✓</span>
<td>
<span style="color: green;">✓</span>
<tr>
<td style="text-align:left;">
Informative
<td>
<span style="color: green;">✓</span>
<td>
<span style="color: green;">✓</span>
<td>
<span style="color: green;">✓</span>
<td>
<span style="color: green;">✓</span>
<tr>
<td style="text-align:left;">
Fast
<td>
<td>
<td>
<span style="color: green;">✓</span>
<td>
<span style="color: green;">✓</span>
</table>
<p>And in our opinion what each package does best <strong>in the context of function parameter checking</strong>:</p>
<ul>
<li><code>assertthat</code>: no learning curve, better error messages.</li>
<li><code>assertive</code>: excellent error messages.</li>
<li><code>checkmate</code>: powerful semantics for checking vectors, fast.</li>
<li><code>vetr</code>: powerful semantics for checking complex object structure, fast.</li>
</ul>
<p>More details on the categories in the summary table:</p>
</div>
<div id="simple" class="section level3">
<h3>Simple</h3>
<p>Ideally packages should have a minimal learning curve.</p>
<ul>
<li><code>asserthat</code> hews closely to <code>stopifnot</code> semantics so it is trivial to learn.</li>
<li><code>assertive</code>, <code>checkmate</code> require familiarity with their many <a href="#predicate-function">Predicate Functions</a>.</li>
<li><code>vetr</code> requires understanding how to build the templates used in structure checks.</li>
</ul>
</div>
<div id="concise" class="section level3">
<h3>Concise</h3>
<p>The benefit to increased complexity is the ability to express complex requirements succinctly:</p>
<ul>
<li><code>checkmate</code> provides highly configurable functions, and a domain specific language for vector checks.</li>
<li><code>vetr</code> infers all required structural checks from a template object.</li>
<li><code>assertive</code> is focused on single parameter <a href="#predicate-function">Predicate Functions</a>, which leads to more verbose checks.</li>
<li><code>assertthat</code> relies primarily<sup><a href="#fn-1">1</a></sup> on standard R expressions so is equivalent to <code>stopifnot</code> in this respect.</li>
</ul>
</div>
<div id="informative" class="section level3">
<h3>Informative</h3>
<p>One drawback for <code>stopifnot</code> is that the error messages it produces are sometimes cryptic. All the reviewed packages seek to improve on this:</p>
<ul>
<li><code>assertthat</code> has clearer error messages for the base <code>is.*</code>, <code>any</code>, <code>all</code>, and the handful of bundled <a href="#predicate-function">Predicate Functions</a>, although no additional information is provided except for <code>any</code> and <code>all</code> (position of failure).</li>
<li><code>assertive</code>, and <code>checkmate</code> provide clearer error messages with additional information for the included <a href="#predicate-function">Predicate Functions</a>, particularly for <code>assertive</code>.</li>
<li><code>vetr</code> provide clearer error messages with additional information for object structure (type, length, attributes), and for values with <code>all_bw</code>.</li>
</ul>
<p>All packages allow users to attach custom error messages to <a href="#check-expression">Check Expressions</a> or <a href="#predicate-function">Predicate Functions</a>, but here we focus on those available “out of the box”.</p>
</div>
<div id="fast" class="section level3">
<h3>Fast</h3>
<p>Parameter checks should add minimal overhead.</p>
<ul>
<li><code>stopifnot</code> is as fast as the R expressions you use for it.</li>
<li><code>assertthat</code> is comparable but adds some overhead.</li>
<li><code>assertive</code> is substantially slower.</li>
<li><code>checkmate</code> is fastest for simple checks, and faster for vectors.</li>
<li><code>vetr</code> is fastest for long vectors and complex objects.</li>
</ul>
<p>We base our conclusions on the tests we ran. It is entirely possible different tests could lead to different results. See <a href="#benchmarks">benchmarks</a>.</p>
<p><a name="details"></a></p>
</div>
</div>
<div id="comparison-details" class="section level2">
<h2>Comparison Details</h2>
<div style="font-size: .8em; margin-top: -12px;">
<div class="line-block"><a href="#top">Top</a> | <a href="#overview">Overview</a> | <a href="#details">Details</a> | <a href="#benchmarks">Benchmarks</a> | <a href="#appendix">Appendix</a></div>
</div>
<div id="simple-parameters" class="section level3">
<h3>Simple Parameters</h3>
<p>We want to write a functions that accept a length two numeric vector with no missing values. To illustrate we use functions that enforce that requirement and do nothing else, starting with <code>stopifnot</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1">simple_stopifnot &lt;-<span class="st"> </span><span class="cf">function</span>(x)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="kw">stopifnot</span>(<span class="kw">is.numeric</span>(x), <span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="dv">2</span>, <span class="op">!</span><span class="kw">is.na</span>(x))</a></code></pre></div>
<p><code>vetr</code> looks similar on the surface:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">simple_vetr_a &lt;-<span class="st"> </span><span class="cf">function</span>(x)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">vetr</span>(<span class="kw">is.numeric</span>(.) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">length</span>(.) <span class="op">==</span><span class="st"> </span><span class="dv">2</span> <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span><span class="kw">is.na</span>(.))</a></code></pre></div>
<p>The <code>vetr</code> arguments are matched to those of the enclosing function. As a result we reference <code>x</code> with <code>.</code>, and we must use <code>&amp;&amp;</code> instead of <code>,</code> to delimit our checks.</p>
<p>Additionally, <code>vetr</code> introduces templates, so we can rewrite <code>simple_vetr_a</code> as:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">simple_vetr &lt;-<span class="st"> </span><span class="cf">function</span>(x)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="kw">vetr</span>(<span class="kw">numeric</span>(2L) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span><span class="kw">is.na</span>(.))</a></code></pre></div>
<p><code>numeric(2L) &amp;&amp; !is.na(.)</code> is a <a href="#vetting-expression">Vetting Expression</a> that contains the <a href="#templated-token">Template Token</a> <code>numeric(2L)</code>, and the <a href="#standard-token">Standard Token</a> <code>!is.na(.)</code>. <a href="#templated-token">Template Tokens</a> require that parameters match their structure (i.e. length, type, and attributes). <a href="#standard-token">Standard Tokens</a>, marked by the presence of the <code>.</code> symbol, are evaluated as they would be by <code>stopifnot</code>.</p>
<p>Templates should be familiar to <code>vapply</code> users, but there are some wrinkles. For example zero-length templates like <code>numeric()</code> match any length objects. See <code>?vetr::alike</code> and <code>vignette('alike', 'vetr')</code> for details.</p>
<p><code>asserthat</code> is like <code>stopifnot</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">simple_assertthat &lt;-<span class="st"> </span><span class="cf">function</span>(x)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="kw">assert_that</span>(<span class="kw">is.numeric</span>(x), <span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="dv">2</span>, <span class="op">!</span><span class="kw">anyNA</span>(x))</a></code></pre></div>
<p><code>assertive</code> and <code>checkmate</code> rely on the <a href="#predicate-function">Predicate Functions</a> and the accompanying assertions they implement:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># assertive: 200+ simple Predicate Functions</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">simple_assertive &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">assert_is_numeric</span>(x)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">assert_is_of_length</span>(x, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="kw">assert_all_are_not_na</span>(x)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="co"># checkmate: 40+ flexible/complex Predicate Functions</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">simple_checkmate &lt;-<span class="st"> </span><span class="cf">function</span>(x)</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  <span class="kw">assertNumeric</span>(x, <span class="dt">any.missing=</span><span class="ot">FALSE</span>, <span class="dt">len=</span><span class="dv">2</span>)</a></code></pre></div>
<p>For this type of check the improvements from the third party packages seem marginal until we look at the result with an illegal parameter:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">simple_stopifnot</span>(pi)</a></code></pre></div>
<pre><code>Error: length(x) == 2 is not TRUE</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">simple_vetr</span>(pi)</a></code></pre></div>
<pre><code>Error in simple_vetr(x = pi): For argument `x`, `length(pi)` should be 2 (is 1)</code></pre>
<p>In addition to what our parameter is not, <code>vetr</code> tells you what it is, gives you the original call of the function, and gives you the input as it appears in the calling frame (i.e. <code>length(pi)</code> instead of <code>length(x)</code>).</p>
<p><code>assertthat</code> makes the error message friendlier, but does not add information:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">simple_assertthat</span>(pi)</a></code></pre></div>
<pre><code>Error: length(x) not equal to 2</code></pre>
<p>The other packages improve on the error message, in particular by telling you what the object is in addition to what it is not:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">simple_assertive</span>(pi)</a></code></pre></div>
<pre><code>Error in simple_assertive(pi): is_of_length : x has length 1, not 2.</code></pre>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">simple_checkmate</span>(pi)</a></code></pre></div>
<pre><code>Error in rmarkdown::render(&quot;extra/compare.Rmd&quot;): Assertion on 'x' failed: Must have length 2, but has length 1.</code></pre>
</div>
<div id="complex-objects" class="section level3">
<h3>Complex Objects</h3>
<p>Here we wish to verify that an input conforms to the structure of the <code>iris</code> built-in data set.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co"># make a bad version of iris</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">iris.fake &lt;-<span class="st"> </span>iris</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">levels</span>(iris.fake<span class="op">$</span>Species)[<span class="dv">3</span>] &lt;-<span class="st"> &quot;sibirica&quot;</span>   <span class="co"># tweak levels</span></a></code></pre></div>
<p>Then, with <code>stopifnot</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1">iris.col.classes &lt;-<span class="st"> </span><span class="kw">lapply</span>(iris, class)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">complex_stopifnot &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">stopifnot</span>(</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    <span class="kw">is.data.frame</span>(x),                     <span class="co"># this only checks class</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    <span class="kw">is.list</span>(x),</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    <span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="kw">length</span>(iris),</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">    <span class="kw">identical</span>(<span class="kw">lapply</span>(x, class), iris.col.classes),</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">    <span class="kw">is.integer</span>(<span class="kw">attr</span>(x, <span class="st">'row.names'</span>)),</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">    <span class="kw">identical</span>(<span class="kw">names</span>(x), <span class="kw">names</span>(iris)),</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">    <span class="kw">identical</span>(<span class="kw">typeof</span>(x<span class="op">$</span>Species), <span class="st">&quot;integer&quot;</span>),</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    <span class="kw">identical</span>(<span class="kw">levels</span>(x<span class="op">$</span>Species), <span class="kw">levels</span>(iris<span class="op">$</span>Species))</a>
<a class="sourceLine" id="cb17-13" data-line-number="13">) }</a>
<a class="sourceLine" id="cb17-14" data-line-number="14"><span class="kw">complex_stopifnot</span>(iris.fake)</a></code></pre></div>
<pre><code>Error: identical(levels(x$Species), levels(iris$Species)) is not TRUE</code></pre>
<p>While some of these checks may seem over-the-top, R’s informality with respect to S3 classes make them necessary. For example, nothing guarantees that an object with class “data.frame” has type “list” as it should.</p>
<p><code>vetr</code> carries out all those checks and more by inferring them from a template:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co"># zero row DF contains structure info only, and matches any # of rows</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">iris.template &lt;-<span class="st"> </span>iris[<span class="dv">0</span>,]</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">complex_vetr &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">vetr</span>(iris.template)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"><span class="kw">complex_vetr</span>(iris.fake)</a></code></pre></div>
<pre><code>Error in complex_vetr(x = iris.fake): For argument `x`, `levels(iris.fake$Species)[3]` should be &quot;virginica&quot; (is &quot;sibirica&quot;)</code></pre>
<p><code>vetr</code> recursively traverses the template and the function parameter in parallel and checks each sub element of the latter against the former. The error messages are also better. Notice how you can copy all of or part of <code>levels(iris.fake$Species)[3]</code> from the message into the R prompt for further examination.</p>
<p><code>checkmate</code> is reasonably succinct:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1">complex_checkmate &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="kw">assertDataFrame</span>(x, <span class="dt">types=</span><span class="kw">unlist</span>(iris.col.classes), <span class="dt">ncols=</span><span class="dv">5</span>)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="kw">assertTRUE</span>(<span class="kw">is.list</span>(x))</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="kw">assertInteger</span>(<span class="kw">attr</span>(x, <span class="st">'row.names'</span>))</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  <span class="kw">assertNames</span>(<span class="kw">names</span>(x), <span class="dt">identical.to=</span><span class="kw">names</span>(iris))</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  <span class="kw">assertFactor</span>(x<span class="op">$</span>Species, <span class="dt">levels=</span><span class="kw">levels</span>(iris<span class="op">$</span>Species))</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="kw">complex_checkmate</span>(iris.fake)</a></code></pre></div>
<pre><code>Error in rmarkdown::render(&quot;extra/compare.Rmd&quot;): Assertion on 'x$Species' failed: Must have levels: setosa,versicolor,virginica.</code></pre>
<p><code>assertive</code>, and <code>assertthat</code> end up with the same number of explicit checks as <code>stopifnot</code>, and with similar error messages so we omit them here. See the code appendix for those implementations.</p>
</div>
<div id="vector-values" class="section level3">
<h3>Vector Values</h3>
<p>Suppose we wish to ensure our input is a strictly positive numeric vector with no missing values. With <code>vec &lt;- -1:1</code> and <code>stopifnot</code> we would use:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1">vector_stopifnot &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">stopifnot</span>(<span class="kw">is.numeric</span>(x), <span class="op">!</span><span class="kw">anyNA</span>(x), <span class="kw">all</span>(x <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>))</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="kw">vector_stopifnot</span>(vec)</a></code></pre></div>
<pre><code>Error: all(x &gt; 0) is not TRUE</code></pre>
<p><code>vetr</code> implements the <code>all_bw</code> function primarily for speed, but it also generates more useful error messages:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1">vector_vetr &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">vetr</span>(<span class="kw">numeric</span>() <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">all_bw</span>(., <span class="dt">lo=</span><span class="dv">0</span>, <span class="dt">bounds=</span><span class="st">&quot;(]&quot;</span>))</a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="kw">vector_vetr</span>(vec)</a></code></pre></div>
<pre><code>Error in vector_vetr(x = vec): For argument `x`, `all_bw(vec, lo = 0, bounds = &quot;(]&quot;)` is not TRUE (is chr: &quot;`-1` at index 1 not in `(0,Inf]`&quot;)</code></pre>
<p><code>asserthat</code> is like <code>stopifnot</code>, with a better error message:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1">vector_assertthat &lt;-<span class="st"> </span><span class="cf">function</span>(x)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  <span class="kw">assert_that</span>(<span class="kw">is.numeric</span>(x), <span class="op">!</span><span class="kw">anyNA</span>(x), <span class="kw">all</span>(x <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>))</a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="kw">vector_assertthat</span>(vec)</a></code></pre></div>
<pre><code>Error: Elements 1, 2 of x &gt; 0 are not true</code></pre>
<p><code>checkmate</code> implements a powerful notation for checking vectors:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1">vector_checkmate &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">qassert</span>(x, <span class="st">&quot;N*(0,]&quot;</span>)</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="kw">vector_checkmate</span>(vec)</a></code></pre></div>
<pre><code>Error in rmarkdown::render(&quot;extra/compare.Rmd&quot;): Assertion on 'x' failed. All elements must be &gt; 0.</code></pre>
<p><code>assertive</code> has a custom function for the job, with a particularly helpful error message:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1">vector_assertive &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">assert_all_are_positive</span>(x)</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="kw">vector_assertive</span>(vec)</a></code></pre></div>
<pre><code>Error in vector_assertive(vec): is_positive : x contains non-positive values.
There were 2 failures:
  Position Value   Cause
1        1    -1 too low
2        2     0 too low</code></pre>
</div>
<div id="compound-checks" class="section level3">
<h3>Compound Checks</h3>
<p>If you wish to build re-usable complex checks with <code>stopifnot</code>, <code>asserthat</code>, <code>assertive</code>, and <code>checkmate</code> you do so by writing new functions. <code>vetr</code> implements a special type of programmable <a href="#nse">Non Standard Evaluation</a>. Here we write a <a href="#vetting-expression">Vetting Expression</a> that accepts either a square numeric matrix, or a scalar numeric:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1">sqr.mx &lt;-<span class="st"> </span><span class="kw">quote</span>(<span class="kw">ncol</span>(.) <span class="op">==</span><span class="st"> </span><span class="kw">nrow</span>(.))</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">num.mx &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">numeric</span>(), <span class="dv">0</span>, <span class="dv">0</span>)       <span class="co"># 0 x 0 matrix, matches any matrix</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">sqr.num.mx &lt;-<span class="st"> </span><span class="kw">quote</span>(sqr.mx <span class="op">&amp;&amp;</span><span class="st"> </span>num.mx)</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">sqr.num.mx.or.sclr.num &lt;-<span class="st"> </span><span class="kw">quote</span>(sqr.num.mx <span class="op">||</span><span class="st"> </span><span class="kw">numeric</span>(1L))</a>
<a class="sourceLine" id="cb33-5" data-line-number="5"></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">compound_vetr &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">vetr</span>(sqr.num.mx.or.sclr.num)</a>
<a class="sourceLine" id="cb33-7" data-line-number="7"></a>
<a class="sourceLine" id="cb33-8" data-line-number="8">rect.mx &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">12</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb33-9" data-line-number="9"><span class="kw">compound_vetr</span>(rect.mx)</a></code></pre></div>
<pre><code>Error in compound_vetr(x = rect.mx): For argument `x` at least one of these should pass:
  - `length(rect.mx)` should be 1 (is 12)
  - `ncol(rect.mx) == nrow(rect.mx)` is not TRUE (FALSE)</code></pre>
<p><code>vetr</code> recursively substitutes symbols in the <a href="#vetting-expression">Vetting Expression</a> which makes it very easy to assemble complex expressions from simple ones by using <code>quote</code>. Note that standalone templates like <code>matrix(numeric(), 0, 0)</code> need not be quoted.</p>
</div>
</div>
<div id="benchmarks" class="section level2">
<h2>Benchmarks</h2>
<div style="font-size: .8em; margin-top: -12px;">
<div class="line-block"><a href="#top">Top</a> | <a href="#overview">Overview</a> | <a href="#details">Details</a> | <a href="#benchmarks">Benchmarks</a> | <a href="#appendix">Appendix</a></div>
</div>
<div id="detail-benchmarks" class="section level3">
<h3>Detail Benchmarks</h3>
<p>We benchmark the functions with <code>mb</code>, a thin wrapper around <code>microbenchmark</code> (see the <a href="#appendix">appendix</a> for its definition). We focus on timings for checks that succeed.</p>
<p>Starting with the simple checks on <code>nums &lt;- runif(2)</code>:</p>
<pre><code>Unit: microseconds, neval:   100

                     expr      lq  median      uq    mean
5  simple_checkmate(nums)     5.4     8.2    10.3    20.0
1  simple_stopifnot(nums)    12.2    15.2    18.5    40.4
2       simple_vetr(nums)    23.1    29.3    32.3    49.0
4 simple_assertthat(nums)    48.0    56.3    67.2    93.1
3  simple_assertive(nums)   709.1   738.8   825.5   816.8</code></pre>
<p><code>stopifnot</code> and <code>checkmate</code> lead the way, with <code>vetr</code> not too far behind.</p>
<p>For complex objects <code>vetr</code> takes the lead:</p>
<pre><code>Unit: microseconds, neval:   100

                      expr        lq    median        uq      mean
5       complex_vetr(iris)      34.2      45.3      54.0      57.6
4  complex_stopifnot(iris)      73.9      85.1      99.5     193.2
2 complex_assertthat(iris)     174.2     196.2     225.0     309.9
3  complex_checkmate(iris)     265.1     313.3     352.3     395.9
1  complex_assertive(iris)   2,644.5   2,873.1   3,129.5   3,151.3</code></pre>
<p><code>vetr</code> is the fastest option for checking that values in a long vector are in range:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" data-line-number="1">str.pos.vec &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">5e5</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>  <span class="co"># test with a 500K long vector</span></a></code></pre></div>
<pre><code>Unit: microseconds, neval:   100

                            expr        lq    median        uq      mean
4       vector_vetr(str.pos.vec)     458.0     476.8     502.1     515.6
2  vector_checkmate(str.pos.vec)   1,722.2   1,770.8   1,865.0   1,821.5
3  vector_stopifnot(str.pos.vec)   2,702.1   2,986.2   3,837.1   3,703.9
1 vector_assertthat(str.pos.vec)   2,852.8   3,408.0   3,937.9   3,897.2</code></pre>
<p>This is primarily because we use <code>vetr::all_bw</code> instead of the semantically similar <code>isTRUE(all(. &gt; 0))</code> expression. <code>all_bw</code> is implemented in C and avoids the intermediate vectors required to evaluate the standard R version. <code>checkmate</code> does the same with <code>qassert</code>.</p>
<p><code>assertive</code> is substantially slower so we benchmark it separately:</p>
<pre><code>Unit: milliseconds, neval:   5

                           expr      lq  median      uq    mean
1 vector_assertive(str.pos.vec)   790.2   812.1   878.3   845.6</code></pre>
<p>If your functions will never be run thousands of times then you probably do not need to worry about the differences shown here. However, general purpose parameter check functions should be compatible with functions that are, and in those cases microseconds matter.</p>
</div>
<div id="making-vetr-faster" class="section level3">
<h3>Making <code>vetr</code> Faster</h3>
<p>We made a design choice with <code>vetr</code> that the overhead associated with running two <code>match.call</code> calls was worth the features it allowed us to implement. In some cases even those ~10 microseconds are too much. For those you can use <code>vet</code> which is a general purpose object checker that uses <a href="#vetting-expression">Vetting Expressions</a> just like <code>vetr</code>, or go even further and call <code>vetr::alike</code> directly to do template comparisons:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1">simple_vet &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">vet</span>(<span class="kw">numeric</span>(2L) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span><span class="kw">anyNA</span>(.), x, <span class="dt">stop=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="kw">simple_vet</span>(pi)</a></code></pre></div>
<pre><code>Error in vet(numeric(2L) &amp;&amp; !anyNA(.), x, stop = TRUE): `length(x)` should be 2 (is 1)</code></pre>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1">simple_alike &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">  <span class="cf">if</span>(<span class="op">!</span><span class="kw">isTRUE</span>(msg &lt;-<span class="st"> </span><span class="kw">alike</span>(<span class="kw">numeric</span>(2L), x))) <span class="kw">stop</span>(<span class="st">&quot;Argument `x` invalid: &quot;</span>, msg)</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">  <span class="cf">if</span>(<span class="kw">anyNA</span>(x)) <span class="kw">stop</span>(<span class="st">&quot;Argument `x` contains NAs&quot;</span>)</a>
<a class="sourceLine" id="cb42-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb42-5" data-line-number="5"><span class="kw">simple_alike</span>(pi)</a></code></pre></div>
<pre><code>Error in simple_alike(pi): Argument `x` invalid: `length(x)` should be 2 (is 1)</code></pre>
<p>The error messages / ease of use degrade, but we do improve our timings (again, with <code>nums &lt;- runif(2)</code>):</p>
<pre><code>Unit: microseconds, neval:   10,000

                    expr     lq median     uq   mean
3 simple_checkmate(nums)    4.3    4.7    5.5    5.6
4     simple_alike(nums)    4.3    4.7    5.5    5.9
1       simple_vet(nums)   10.9   11.6   13.2   16.9
2      simple_vetr(nums)   18.5   19.5   21.9   27.4</code></pre>
</div>
</div>
<div id="conclusions" class="section level2">
<h2>Conclusions</h2>
<div style="font-size: .8em; margin-top: -12px;">
<div class="line-block"><a href="#top">Top</a> | <a href="#overview">Overview</a> | <a href="#details">Details</a> | <a href="#benchmarks">Benchmarks</a> | <a href="#appendix">Appendix</a></div>
</div>
<p>Take these with a grain of salt, as they are written by the <code>vetr</code> author:</p>
<p>In favor of <code>vetr</code>:</p>
<ul>
<li>Best package for checking complex S3 structure.</li>
<li>Fastest package for non-trivial checks.</li>
</ul>
<p>Against <code>vetr</code>:</p>
<ul>
<li>New package (beta testers welcome!).</li>
<li>Template concept is designed to be intuitive, but inevitably in some corner cases it will require deeper understanding of the underlying rules.</li>
</ul>
<p>If you are tired of dealing with checks for non-trivial S3 objects and are willing to try out a young package, <code>vetr</code> is for you. If not, we would recommend<sup><a href="#fn-2">2</a></sup> <code>checkmate</code> as it is fast, well established, and more expressive than the other options.</p>
</div>
<div id="appendix" class="section level2">
<h2>Appendix</h2>
<div style="font-size: .8em; margin-top: -12px;">
<div class="line-block"><a href="#top">Top</a> | <a href="#overview">Overview</a> | <a href="#details">Details</a> | <a href="#benchmarks">Benchmarks</a> | <a href="#appendix">Appendix</a></div>
</div>
<div id="definitions" class="section level3">
<h3>Definitions</h3>
<p>Definitions of terms as we use them in this document. They may have different definitions elsewhere.</p>
<dl>
<dt>
<a name="check-function"></a>Check Function
</dt>
<dd>
Similar to a <a href="#predicate-function">Predicate Function</a>, may return either TRUE or a vector of only TRUE values on success, and something else on failure. <code>all.equal(x, y)</code> is a common example. Check Functions should be used within <code>isTRUE(all(check_fun(...)))</code> to establish success or failure, unless they are used within <code>stopifnot</code> or <code>vetr</code> where such a check is implicit.
</dd>
<dt>
<a name="check-expression"></a>Check Expression
</dt>
<dd>
A collection of calls to <a href="#check-function">Check</a> and/or <a href="#predicate-function">Predicate Functions</a> combined with logical operators. For example <code>!anyNA(x) &amp;&amp; x &gt; 0</code>.
</dd>
<dt>
<a name="nse"></a>Non Standard Evaluation
</dt>
<dd>
Refers to the evaluation of an R expression different than would normally occur, because the expression is modified prior to evaluation, it is evaluated in a different environment than it would normally be, or both. A classic example is <code>subset(x, subset)</code> where the <code>subset</code> argument is evaluated within <code>x</code> instead of in the parent frame. <code>vetr</code> implements a special type of Non Standard Evaluation that recursively substitutes all non-function symbols (i.e. symbols not at position 1 in a call) that resolve to symbols until the resulting expression only contains symbols that point to non-symbol R objects. It also substitutes <code>.</code> with the corresponding function parameter. Finally, it tokenizes the expression by breaking it apart into by <code>&amp;&amp;</code> and <code>||</code>, and evaluates each token separately.
</dd>
<dt>
<a name="predicate-function"></a>Predicate Function
</dt>
<dd>
Function that typically accepts one non-optional argument and returns TRUE or FALSE according to whether that argument conforms to a requirement. <code>isTRUE(x)</code> and <code>is.numeric(x)</code> are single argument examples, and <code>identical(x, y)</code> is a two argument example.
</dd>
<dt>
<a name="standard-token"></a>Standard Token
</dt>
<dd>
Part of a <a href="#vetting-expression">Vetting Expression</a> that should be treated as a standard R expression. If <code>isTRUE(all(evaluated_standard_token))</code> then the token will be considered to pass. <a href="#standard-token">Standard Tokens</a> are identified by the presence of a <code>.</code> symbol within a token. You can also wrap expressions in <code>.()</code> to mark them as standard tokens. If you need to use the <code>.</code> symbol for other purposes escape it with another <code>.</code> (i.e. to use a literal <code>.</code>, use <code>..</code>). See <code>vignette('vetr', 'vetr')</code> for more details.
</dd>
<dt>
<a name="template-token"></a>Template Token
</dt>
<dd>
Part of a <a href="#vetting-expression">Vetting Expression</a> that should be treated as a template by <code>vetr</code>. It should resolve to an R object when it is evaluated in the calling frame of the enclosing function to the <code>vetr</code> call. See <code>vignette('vetr', 'vetr')</code> for more details.
</dd>
<dt>
<a name="vetting-expression"></a>Vetting Expression
</dt>
<dd>
Like a <a href="#check-expression">Check Expression</a>, but augmented for use in <code>vetr</code>. In addition to Check and <a href="#predicate-function">Predicate Function</a> calls, it can include <a href="#templated-token">Template Tokens</a>. References to the object being checked should be made with the <code>.</code> symbol. For example <code>numeric(1L) &amp;&amp; !is.na(.) &amp;&amp; . &gt; 0</code>, is made up of three tokens, where <code>numeric(1L)</code> is a <a href="#templated-token">Template Token</a>, and <code>!is.na(.)</code> and <code>. &gt; 0</code> are <a href="#standard-token">Standard Tokens</a>. Beware of accidentally referencing a variable in a token intended to be a <a href="#standard-token">Standard Token</a>. If we had used <code>x &gt; 0</code> instead of <code>. &gt; 0</code>, <code>vetr</code> would evaluate <code>x &gt; 0</code> and use the result as a template since <code>x &gt; 0</code> does not contain the <code>.</code> symbol to mark it as a <a href="#standard-token">Standard Token</a>. See <code>vignette('vetr', 'vetr')</code> for more details.
</dd>
<dt>
<a name="vetting-token"></a>Vetting Token
</dt>
<dd>
Component piece of <a href="#vetting-expression">Vetting Expressions</a>. May be either <a href="#standard-token">Standard Tokens</a> or <a href="#templated-token">Template Tokens</a>. <a href="#vetting-token">Vetting Tokens</a> are the arguments to “top level” <code>&amp;&amp;</code>, <code>||</code>, and <code>(</code> calls. For example, in the <a href="#vetting-expression">Vetting Expression</a> <code>!anyNA(.) &amp;&amp; I(. &gt; 0 &amp;&amp; interactive())</code> there are two <a href="#vetting-token">Vetting Tokens</a>: <code>!anyNA(.)</code> and <code>I(. &gt; 0 &amp;&amp; interactive())</code>. The <code>&amp;&amp;</code> inside <code>I(...)</code> is not considered to be at the “top level” because of the intervening <code>I</code> call.
</dd>
</dl>
</div>
<div id="references" class="section level3">
<h3>References</h3>
<ul>
<li>Help, vignettes, and READMEs for <code>assertthat</code>, <code>assertive</code>, <code>checkmate</code>, <code>ensurer</code>, and <code>valaddin</code>.</li>
<li><a href="https://journal.r-project.org/archive/2017/RJ-2017-028/index.html">checkmate: Fast Argument Checks for Defensive Programming in R</a>, Michel Lang, The R Journal (2017) 9:1, pages 437-445.</li>
<li><a href="https://4dpiecharts.com/2015/07/03/the-state-of-assertions-in-r/">The State of Assertions in R</a>, Richie Cotton, July 2015</li>
<li><a href="https://www.crcpress.com/Testing-R-Code/Cotton/p/book/9781498763653">Testing R Code</a>, Richie Cotton, January 2017</li>
</ul>
</div>
<div id="ancillary-code" class="section level3">
<h3>Ancillary Code</h3>
<div id="benchmarking-function" class="section level4">
<h4>Benchmarking Function</h4>
<p>We use a thin wrapper around <code>microbenchmark</code>:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1">mb &lt;-<span class="st"> </span><span class="cf">function</span>(...) {</a>
<a class="sourceLine" id="cb45-2" data-line-number="2">  mb.call &lt;-<span class="st"> </span><span class="kw">match.call</span>()</a>
<a class="sourceLine" id="cb45-3" data-line-number="3">  mb.call[[<span class="dv">1</span>]] &lt;-<span class="st"> </span><span class="kw">quote</span>(microbenchmark<span class="op">::</span>microbenchmark)</a>
<a class="sourceLine" id="cb45-4" data-line-number="4">  <span class="kw">gc</span>()</a>
<a class="sourceLine" id="cb45-5" data-line-number="5">  mb.dat &lt;-<span class="st"> </span><span class="kw">eval</span>(mb.call, <span class="dt">envir=</span><span class="kw">parent.frame</span>())</a>
<a class="sourceLine" id="cb45-6" data-line-number="6">  mb.res &lt;-<span class="st"> </span><span class="kw">summary</span>(mb.dat)</a>
<a class="sourceLine" id="cb45-7" data-line-number="7">  mb.res &lt;-<span class="st"> </span>mb.res[<span class="kw">order</span>(mb.res<span class="op">$</span>median), ]</a>
<a class="sourceLine" id="cb45-8" data-line-number="8">  mb.res[, <span class="dv">-1</span>] &lt;-<span class="st"> </span><span class="kw">lapply</span>(</a>
<a class="sourceLine" id="cb45-9" data-line-number="9">    mb.res[, <span class="dv">-1</span>], <span class="cf">function</span>(x) <span class="kw">sprintf</span>(<span class="st">&quot;  %s&quot;</span>, <span class="kw">format</span>(<span class="kw">round</span>(x, <span class="dv">1</span>), <span class="dt">big.mark=</span><span class="st">&quot;,&quot;</span>))</a>
<a class="sourceLine" id="cb45-10" data-line-number="10">  )</a>
<a class="sourceLine" id="cb45-11" data-line-number="11">  <span class="kw">cat</span>(</a>
<a class="sourceLine" id="cb45-12" data-line-number="12">    <span class="kw">sprintf</span>(<span class="st">&quot;Unit: %s, neval: %s</span><span class="ch">\n\n</span><span class="st">&quot;</span>, <span class="kw">attr</span>(mb.res, <span class="st">'unit'</span>), mb.res<span class="op">$</span>neval[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb45-13" data-line-number="13">  )</a>
<a class="sourceLine" id="cb45-14" data-line-number="14">  <span class="kw">print</span>(mb.res[, <span class="kw">c</span>(<span class="st">'expr'</span>, <span class="st">'lq'</span>, <span class="st">'median'</span>, <span class="st">'uq'</span>, <span class="st">'mean'</span>)], <span class="dt">quote=</span><span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb45-15" data-line-number="15">}</a></code></pre></div>
</div>
<div id="complex-objects-for-other-packages" class="section level4">
<h4>Complex Objects for Other Packages</h4>
<p>These are the implementations we omitted from the iris checks in the <a href="#details">details section</a>.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" data-line-number="1">complex_assertive &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">  <span class="kw">assert_is_list</span>(x)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">  <span class="kw">assert_all_are_equal_to</span>(<span class="kw">length</span>(x), <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb46-4" data-line-number="4">  <span class="kw">assert_is_integer</span>(<span class="kw">attr</span>(x, <span class="st">'row.names'</span>))</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">  <span class="kw">assert_is_data.frame</span>(x)</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">  <span class="kw">assert_is_identical_to_true</span>(<span class="kw">identical</span>(iris.col.classes, <span class="kw">lapply</span>(x, class)))</a>
<a class="sourceLine" id="cb46-7" data-line-number="7">  <span class="kw">assert_is_identical_to_true</span>(<span class="kw">identical</span>(<span class="kw">names</span>(x), <span class="kw">names</span>(iris)))</a>
<a class="sourceLine" id="cb46-8" data-line-number="8">  <span class="kw">assert_is_identical_to_true</span>(<span class="kw">identical</span>(<span class="kw">typeof</span>(x<span class="op">$</span>Species), <span class="st">&quot;integer&quot;</span>))</a>
<a class="sourceLine" id="cb46-9" data-line-number="9">  <span class="kw">assert_is_factor</span>(x<span class="op">$</span>Species)</a>
<a class="sourceLine" id="cb46-10" data-line-number="10">  <span class="kw">assert_is_identical_to_true</span>(</a>
<a class="sourceLine" id="cb46-11" data-line-number="11">    <span class="kw">identical</span>(<span class="kw">levels</span>(x<span class="op">$</span>Species), <span class="kw">levels</span>(iris<span class="op">$</span>Species))</a>
<a class="sourceLine" id="cb46-12" data-line-number="12">  )</a>
<a class="sourceLine" id="cb46-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb46-14" data-line-number="14">complex_assertthat &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb46-15" data-line-number="15">  <span class="kw">assert_that</span>(</a>
<a class="sourceLine" id="cb46-16" data-line-number="16">    <span class="kw">is.data.frame</span>(x),                     <span class="co"># this only checks class</span></a>
<a class="sourceLine" id="cb46-17" data-line-number="17">    <span class="kw">is.list</span>(x),</a>
<a class="sourceLine" id="cb46-18" data-line-number="18">    <span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="kw">length</span>(iris),</a>
<a class="sourceLine" id="cb46-19" data-line-number="19">    <span class="kw">identical</span>(<span class="kw">lapply</span>(x, class), iris.col.classes),</a>
<a class="sourceLine" id="cb46-20" data-line-number="20">    <span class="kw">is.integer</span>(<span class="kw">attr</span>(x, <span class="st">'row.names'</span>)),</a>
<a class="sourceLine" id="cb46-21" data-line-number="21">    <span class="kw">identical</span>(<span class="kw">names</span>(x), <span class="kw">names</span>(iris)),</a>
<a class="sourceLine" id="cb46-22" data-line-number="22">    <span class="kw">identical</span>(<span class="kw">typeof</span>(x<span class="op">$</span>Species), <span class="st">&quot;integer&quot;</span>),</a>
<a class="sourceLine" id="cb46-23" data-line-number="23">    <span class="kw">identical</span>(<span class="kw">levels</span>(x<span class="op">$</span>Species), <span class="kw">levels</span>(iris<span class="op">$</span>Species))</a>
<a class="sourceLine" id="cb46-24" data-line-number="24">) }</a></code></pre></div>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="kw">complex_assertive</span>(iris.fake)</a></code></pre></div>
<pre><code>Error in complex_assertive(iris.fake): is_identical_to_true : identical(levels(x$Species), levels(iris$Species)) is not identical to TRUE; its value is FALSE.</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">complex_assertthat</span>(iris.fake)</a></code></pre></div>
<pre><code>Error: levels(x$Species) not identical to levels(iris$Species)</code></pre>
</div>
</div>
<div id="session-info" class="section level3">
<h3>Session Info</h3>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">sessionInfo</span>()</a></code></pre></div>
<pre><code>R version 3.4.3 (2017-11-30)
Platform: x86_64-apple-darwin15.6.0 (64-bit)
Running under: macOS High Sierra 10.13.3

Matrix products: default
BLAS: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRblas.0.dylib
LAPACK: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] checkmate_1.8.3  assertthat_0.2.0 assertive_0.3-5  vetr_0.2.3.9000 

loaded via a namespace (and not attached):
 [1] Rcpp_0.12.13               assertive.data_0.0-1      
 [3] pillar_1.1.0               compiler_3.4.3            
 [5] plyr_1.8.4                 assertive.files_0.0-2     
 [7] assertive.properties_0.0-4 tools_3.4.3               
 [9] assertive.data.us_0.0-1    digest_0.6.15             
[11] tibble_1.4.2               evaluate_0.10             
[13] memoise_1.1.0              assertive.base_0.0-7      
[15] gtable_0.2.0               rlang_0.1.4               
[17] microbenchmark_1.4-2.1     yaml_2.1.14               
[19] withr_2.1.0                stringr_1.2.0             
[21] knitr_1.20                 assertive.strings_0.0-3   
[23] assertive.types_0.0-3      assertive.datetimes_0.0-2 
[25] assertive.sets_0.0-3       assertive.matrices_0.0-1  
[27] devtools_1.13.5            rprojroot_1.2             
[29] grid_3.4.3                 assertive.code_0.0-1      
[31] rmarkdown_1.9              ggplot2_2.2.1             
[33] magrittr_1.5               backports_1.1.0           
[35] assertive.numbers_0.0-2    scales_0.4.1              
[37] codetools_0.2-15           htmltools_0.3.6           
[39] assertive.models_0.0-1     colorspace_1.3-2          
[41] stringi_1.1.5              assertive.data.uk_0.0-1   
[43] lazyeval_0.2.0             munsell_0.4.3             
[45] assertive.reflection_0.0-4</code></pre>
</div>
<div id="end-notes" class="section level3">
<h3>End Notes</h3>
<p><sup>1</sup><a name="fn-1"></a> <code>assertthat</code> requires <a href="#check-expression">Check Expressions</a> to evaluate to TRUE or FALSE, whereas <code>stopifnot</code> accepts anything, with all TRUE vectors considered a success and all else failure. Additionally, <code>assertthat</code> implements a handful of useful <a href="#predicate-function">Predicate Functions</a> for common checks (e.g. scalars, etc.). <br /> <sup>2</sup><a name="fn-2"></a> Our recommendation for <code>checkmate</code> is made solely on the basis of the tests described in this document. We have not used it in any of our packages.</p>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
