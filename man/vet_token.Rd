% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/validators.R
\docType{data}
\name{vet_token}
\alias{vet_token}
\alias{vet_token}
\alias{NO.NA}
\alias{vet_token}
\alias{NO.INF}
\alias{vet_token}
\alias{GTE.0}
\alias{vet_token}
\alias{LTE.0}
\alias{vet_token}
\alias{GT.0}
\alias{vet_token}
\alias{LT.0}
\alias{vet_token}
\alias{INT.1}
\alias{vet_token}
\alias{INT.1.POS}
\alias{vet_token}
\alias{INT.1.NEG}
\alias{vet_token}
\alias{INT.1.POS.STR}
\alias{vet_token}
\alias{INT.1.NEG.STR}
\alias{vet_token}
\alias{INT}
\alias{vet_token}
\alias{INT.POS}
\alias{vet_token}
\alias{INT.NEG}
\alias{vet_token}
\alias{INT.POS.STR}
\alias{vet_token}
\alias{INT.NEG.STR}
\alias{vet_token}
\alias{NUM.1}
\alias{vet_token}
\alias{NUM.1.POS}
\alias{vet_token}
\alias{NUM.1.NEG}
\alias{vet_token}
\alias{NUM}
\alias{vet_token}
\alias{NUM.POS}
\alias{vet_token}
\alias{NUM.NEG}
\alias{vet_token}
\alias{CHR.1}
\alias{vet_token}
\alias{CHR}
\alias{vet_token}
\alias{CPX}
\alias{vet_token}
\alias{CPX.1}
\alias{vet_token}
\alias{LGL}
\alias{vet_token}
\alias{LGL.1}
\title{Make Vetting Token}
\format{An object of class \code{call} of length 2.}
\usage{
vet_token(exp, err.msg = "\%s")

NO.NA

NO.INF

GTE.0

LTE.0

GT.0

LT.0

INT.1

INT.1.POS

INT.1.NEG

INT.1.POS.STR

INT.1.NEG.STR

INT

INT.POS

INT.NEG

INT.POS.STR

INT.NEG.STR

NUM.1

NUM.1.POS

NUM.1.NEG

NUM

NUM.POS

NUM.NEG

CHR.1

CHR

CPX

CPX.1

LGL

LGL.1
}
\arguments{
\item{exp}{an expression which will be captured but not evaluated}

\item{err.msg}{character(1L) a message that tells the user what the
expected value should be}
}
\value{
a quoted expressions with \code{err.msg} attribute set
}
\description{
Utility function to generate vetting tokens with attached error messages.

Commonly used tokens that can be used as part of validation expressions.
}
\details{
Allows you to supply error messages for vetting to use for each error
token.  Your token should not contain top level \code{&&} or \code{||}.  If
it does your error message will not be reported.  If your token must involve
top level \code{&&} or \code{||}, use \code{identity(x && y)} to ensure that
your error message is used by \code{validate}, but this will only make sense
for a validation expression composed solely of custom tokens.  For example
if you do something like:\preformat{
validate(vet_token(identity(logical(1L) && !is.na(.))), NA)
}
the \code{logical(1L)} will be evaluated as \code{FALSE} and cause validation
to always fail instead of being used as a template token.

Error messages should tell you what the acceptable values are so they mesh
with the rest of the error reporting messages.  Typically, we will append
"Should" ahead of your message, such that if you supply "not contain NAs"
it will be displayed as "Should not contain NAs".

In particular, we predefine several templates useful for atomic vectors. For
example, \code{INT.1.POS.STR} will validate:
\itemize{
  \item \code{INT}: integer-like
  \item \code{1}: length 1
  \item \code{POS.STR}: strictly positive (i.e. > zero)
}
whereas \code{INT} will validate any integer like vector of any length.

Every one of the vetting token documented here implicitly disallows NAs,
and for numerics also disallows infinite values. If you wish to allow NAs or
infinite values just use \code{integer(1L)}.

Keep in mind these vetting tokens are just language objects so you can just
as easily create your own by quoting an R expression or by using
\code{\link{vet_token}} if you also want to attach a custom error message.
}
\examples{
LEN.2 <- vet_token(length(.) == 2, "be length two")
SQR <- vet_token(nrow(.) == ncol(.), "be square")
SQR.NUM.MX <- quote(matrix(numeric(), 0, 0) && SQR)
## Alternative spec: note the use of `bquote`:
SQR.NUM.MX <- bquote(
  matrix(numeric(), 0, 0) && .(vet_token(nrow(.) == ncol(.), "be square"))
)
}
\keyword{datasets}
