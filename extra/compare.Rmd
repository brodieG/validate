---
title: "Parameter Validation Functions"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: ../vignettes/styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(vetr)
library(assertive)
library(assertthat)
library(ensurer)
library(checkmate)
library(valaddin)
```

## Prevent Garbage In

Most functions expect their parameters to be of specific types, structures, or
values.  If we allow functions to operate on parameters that do not conform to
the expectations then we could get in the best case difficult to debug errors
from the bowels of the function, and in the worst silent undefined behavior.

Systematically vetting function parameters is as tedious as it is important, but
fortunately many packages exist to assist with the process.  We will review
those packages and assess them across these dimensions:

* Ease of use for the function developer incorporating parameter checks
* Computing overhead
* Ease of use for end users

We will review:

* `stopifnot` by R Core
* [`vetr`](https://github.com/brodieG/vetr) by Yours Truly
* [`asserthat`](https://github.com/hadley/assertthat) by Hadley Wickham
* [`assertive`](https://www.r-pkg.org/pkg/assertive) by Richie Cotton
* [`checkmate`](https://github.com/mllg/checkmate) by Michael Lang
* [`ensurer`](https://github.com/smbache/ensurer) by Stefan M. Bache

Not all of these packages are specifically designed to test function parameters,
but they can all be used that way.  We ignore functionality that is not
specifically used for function parameter checking.

The following packages also perform related tasks, although we do not review
them here:

* [`valaddin`](https://github.com/egnha/valaddin) by Eugene Ha, a framework for
  augmenting existing functions with validation contracts.  Currently the
  package is undergoing a major overhaul so we will add it to the comparison
  once the new release (v0.3.0) is out.
* [`validate`](https://github.com/data-cleaning/validate) by Mark van
  der Loo and Edwin de Jonge, with a primary focus on validating data in data
  frames and similar data structures
* [`assertr`](https://github.com/ropensci/assertr) by Tony Fischetti, also
  focused on data validation in data frames and similar structures
* [`types`](https://github.com/jimhester/types) by Jim Hester, which implements
  but does not enforce type hinting
* [`argufy`](https://github.com/gaborcsardi/argufy) by Gábor Csárdi, which
  implements parameter validation via roxygen tags (not released to CRAN)

<a name='overview'></a>

## Comparison Overview

```{r child='./compare-nav.Rmd'}
```

### Summary

A summary of each of the packages, as compared to `stopifnot`:

<table>
  <col>
  <col width='100px'>
  <col width='100px'>
  <col width='100px'>
  <col width='100px'>
  <col width='100px'>
<thead>
<tr>
  <th><th>assertthat<th>assertive<th>checkmate<th>ensurer<th>vetr
<tbody style='text-align: center;'>
<tr>
  <td style='text-align:left;'>Simple
  <td><span style='color: green;'>&#10003;</span>
  <td>
  <td>
  <td><span style='color: green;'>&#10003;</span>
  <td>
<tr>
  <td style='text-align:left;'>Concise
  <td>
  <td>
  <td><span style='color: green;'>&#10003;</span>
  <td>
  <td><span style='color: green;'>&#10003;</span>
<tr>
  <td style='text-align:left;'>Informative
  <td><span style='color: green;'>&#10003;</span>
  <td><span style='color: green;'>&#10003;</span>
  <td><span style='color: green;'>&#10003;</span>
  <td>
  <td><span style='color: green;'>&#10003;</span>
<tr>
  <td style='text-align:left;'>Fast
  <td>
  <td>
  <td><span style='color: green;'>&#10003;</span>
  <td>
  <td><span style='color: green;'>&#10003;</span>
</table>

And in our opinion what each package does best **in the context of function
parameter checking**:

* `assertthat`: no learning curve, better error messages
* `assertive`: excellent error messages
* `checkmate`: powerful semantics for checking vectors, fast
* `ensurer`: elegant mechanism for generating assertions
* `vetr`: powerful semantics for checking complex object structure, fast

More details on the categories in the summary table:

### Simple

`assertthat` hews very closely to `stopifnot` semantics so it is trivial to
learn<sup><a href='#fn-1'>1</a></sup>.  `ensurer` is also reasonably simple for
the purposes of checking function parameters.

Every other package adds either many functions, or new concepts that need to
be mastered:

* `assertive`, `checkmate`: extensive libraries of Predicate Functions (e.g.
  `is.something(...)`).  `assertive` focuses on many simple single argument
  Predicate Functions, whereas `checkmate` has a smaller library of more
  flexible and complex multi-argument Predicate Functions.
* `vetr`: declarative template based checks for object structure.

### Concise

The benefit to increased complexity is the ability to express complex
requirements succinctly:

* `checkmate`: highly configurable functions, and domain specific language for
  vector checks.
* `vetr`: verifies structural requirements by comparison to template objects.

`assertive` is focused on single parameter Predicate Functions, which by nature
are limited in their expressive power.  `ensurer` and `assertthat` rely on
standard R expressions so are equivalent to `stopifnot` in this respect.

### Informative

* `assertthat`: clearer error messages for the base `is.*`, `any`, `all`, and
  the handful of bundled Predicate Functions, although no additional information
  is provided except for `any` and `all` (position of failure).
* `assertive`, and `checkmate`: clearer error messages with additional
  information for the included Predicate Functions, particularly for `assertive`.
* `vetr`: clearer error messages with additional informations for object
  structure (type, length, attributes), and for values with `all_bw`.

All packages allow users to attach custom error messages to Check Expressions or
Predicate Functions, but here we focus on those available "out of the box".

### Fast

* `stopifnot` is as fast as the R expressions you use for it.
* `assertthat` is comparable but adds some overhead.
* `checkmate` is fastest for simple checks, and fast for vectors
* `vetr` is fastest for vectors and complex objects
* `ensurer` is slower
* `assertive` is substantially slower

Speed conclusions are based solely on the tests we carried out.  There are
likely circumstances that will result in different outcomes.

<a name='details'></a>

## Comparison Details

```{r child='./compare-nav.Rmd'}
```

### Simple Parameters

We want to write a function that accepts a numeric vector as the first
argument, and TRUE or FALSE as the second.  We start with `stopifnot`, since it
is the simplest and most well known option:

```{r}
simple_stopifnot <- function(num, flag) {
  stopifnot(
    is.numeric(num),
    is.logical(flag), length(flag) == 1, !is.na(flag)
) }
```

`vetr` looks similar on the surface, but:

* it matches each of its parameters to those of the enclosing function
* we use `.` instead of the parameter name
* we combine tokens with `&&` (or `||`) instead of commas

```{r}
simple_vetr_a <- function(num, flag) {
  vetr(
    is.numeric(.),                                # matched to `num`
    is.logical(.) && length(.) == 1 && !is.na(.)  # matched to `flag`
) }
```

Additionally, `vetr` introduces the concept of templates which allow you to
specify object structure declaratively as in `vapply`, so we can rewrite
`simple_vetr_a` as:

```{r}
simple_vetr <- function(num, flag) {
  vetr(
    numeric(),                 # template
    logical(1L) && !is.na(.)   # template && standard token
) }
```

`flag` must be type `logical` and length 1 to match `logical(1L)`.  Similarly
`num` must be numeric to match `numeric()` (we allow length zero
dimensions in templates to match any length dimension in the parameter).  `vetr`
distinguishes between template tokens and standard tokens by the absence or
presence of the `.` symbol.

`asserthat` is almost identical to `stopifnot`, with the stricter
requirement that its arguments must evaluate to TRUE or FALSE exactly, and
the addition of helper Predicate Functions like `is.flag`:

```{r}
simple_assertthat <- function(num, flag) {
  assert_that(
    is.numeric(num),
    is.flag(flag), !is.na(flag)
) }
```

`ensurer` is also similar, although requires a separate call to `ensure` for
each argument and also uses the `.` notation:

```{r}
simple_ensurer <- function(num, flag) {
  ensure(num, is.numeric(.))
  ensure(flag, length(.) == 1 && !is.na(.) && is.logical(.))
}
```

`assertive` and checkmate rely on the Predicate Functions they implement:

```{r}
simple_assertive <- function(num, flag) {
  assert_is_numeric(num)
  assert_is_a_bool(flag)
  assert_all_are_not_na(flag)
}

simple_checkmate <- function(num, flag) {
  assertNumeric(num)
  assertFlag(flag)
}
```

For this type of check none of these packages improve substantially from the
`stopifnot` syntax.  There are differences when we run the functions with
illegal parameters:

```{r}
simple_stopifnot(letters, TRUE)
simple_vetr(letters, TRUE)
```

In addition to what our parameter is not, `vetr` tells you what it is, gives you
the original call of the function, and gives you the expression that corresponds
to the parameter (`letters`) instead of just the parameter name.  This
additional contextual information makes debugging easier.

The other packages include some of this additional information:

```{r}
simple_assertthat(letters, TRUE)
simple_assertive(letters, TRUE)
simple_ensurer(letters, TRUE)
simple_checkmate(letters, TRUE)
```

`assertive`, and `checkmate` tell you what the object is.  `ensurer` and
`checkmate` return the top level call, although that does not match the
semantics of a `stop` call in a function, and is in our opinion less useful.

### Complex Objects

Here we wish to verify that an input conforms to the structure of the `iris`
built-in data set.

```{r}
# collect data for tests
iris.tpl <- vetr::abstract(iris) # equivalently: iris[0, ]
iris.col.classes <- lapply(iris, class)

# make a bad version of iris
iris.fake <- iris
levels(iris.fake$Species)[3] <- "sibirica"   # tweak levels
```

Then, with `stopifnot`:

```{r}
complex_stopifnot <- function(x) {
  stopifnot(
    is.data.frame(x),                     # this only checks class
    is.list(x),
    length(x) == length(iris.tpl),
    identical(lapply(x, class), iris.col.classes),
    is.integer(attr(x, 'row.names')),
    identical(names(x), names(iris.tpl)),
    identical(typeof(x$Species), "integer"),
    identical(levels(x$Species), levels(iris.tpl$Species))
  )
}
complex_stopifnot(iris.fake)
```

In contrast, `vetr` is a one-liner:

```{r}
complex_vetr <- function(x) {
  vetr(iris.tpl)
}
complex_vetr(iris.fake)
```

Rather than painstakingly generating a list of all the comparisons required to
validate the object, we point to an existing object to use as a template. `vetr`
recursively traverses the template and the function parameter in parallel and
checks each sub element of the latter against the former.

`vetr` derives contextual information from the template that it uses to generate
the error messages:

```
`levels(iris.fake$Species)[3]` should be "virginica" (is "sibirica")
```

It is designed so you can copy all of or part of `levels(iris.fake$Species)[3]`
into the R prompt for examination.  It also tells you exactly what is wrong.

`checkmate` is reasonably succinct:

```{r}
complex_checkmate <- function(x) {
  assertDataFrame(x, types=unlist(iris.col.classes), ncols=5)
  assertTRUE(is.list(x))
  assertInteger(attr(x, 'row.names'))
  assertNames(names(x), identical.to=names(iris.tpl))
  assertFactor(x$Species, levels=levels(iris.tpl$Species))
}
complex_checkmate(iris.fake)
```

`assertive`, `assertthat`, and `ensurer`  end up with the same number of
explicit checks as `stopifnot`, and with similar error messages.  See the code
appendix for those implementations.

```{r iris.other, echo=F, eval=F}
complex_assertive <- function(x) {
  assert_is_list(x)
  assert_all_are_equal_to(length(iris), 5)
  assert_is_integer(attr(x, 'row.names'))
  assert_is_data.frame(x)
  assert_is_identical_to_true(identical(iris.col.classes, lapply(x, class)))
  assert_is_identical_to_true(identical(names(x), names(iris.tpl)))
  assert_is_identical_to_true(identical(typeof(x$Species), "integer"))
  assert_is_factor(x$Species)
  assert_is_identical_to_true(
    identical(levels(x$Species), levels(iris.tpl$Species))
  )
}
complex_assertive(iris.fake)

complex_assertthat <- function(x) {
  assert_that(
    is.data.frame(x),                     # this only checks class
    is.list(x),
    length(x) == length(iris.tpl),
    identical(lapply(x, class), iris.col.classes),
    is.integer(attr(x, 'row.names')),
    identical(names(x), names(iris.tpl)),
    identical(typeof(x$Species), "integer"),
    identical(levels(x$Species), levels(iris.tpl$Species))
  )
}
complex_assertthat(iris.fake)

complex_ensurer <- function(x) {
  ensure(
    x,
    is.data.frame(.),                     # this only checks class
    is.list(.),
    length(.) == length(iris.tpl),
    identical(lapply(., class), iris.col.classes),
    is.integer(attr(., 'row.names')),
    identical(names(.), names(iris.tpl)),
    identical(typeof(.$Species), "integer"),
    identical(levels(.$Species), levels(iris.tpl$Species))
  )
}
complex_ensurer(iris.fake)
```

### Vector Values

Suppose we wish to ensure our input is a strictly positive numeric vector with
no missing values.  With `stopifnot` we would
use:

```{r}
vec <- -1:1

vector_stopifnot <- function(num) {
  stopifnot(is.numeric(num), !anyNA(num), all(num > 0))
}
vector_stopifnot(vec)
```

`vetr` includes the `all_bw` function primarily for speed, but it also generates
more useful error messages:

```{r}
vector_vetr <- function(num) {
  vetr(numeric() && all_bw(., 0, Inf,  bounds="(]"))
}
vector_vetr(vec)
```

`asserthat` and `ensurer` end up very similar to `stopifnot`, though
`assertthat` improves the error message:

```{r}
vector_assertthat <- function(num) {
  assert_that(is.numeric(num), !anyNA(num), all(num > 0))
}
vector_assertthat(vec)

vector_ensurer <- function(num) {
  ensure(num, is.numeric(.), !anyNA(num), all(num > 0))
}
vector_ensurer(vec)
```

`checkmate` implements a succinct notation:

```{r}
vector_checkmate <- function(num) {
  qassert(num, "n*(0,]")
}
vector_checkmate(vec)
```

`assertive` has a custom function for the job, with a particularly helpful
error message:

```{r}}
vector_assertive <- function(num) {
  assert_all_are_in_left_open_range(num, lower=0)
}
vector_assertive(vec)
```

### Compound Checks

If you wish to build re-usable complex checks with `stopifnot`  or `asserthat`
you would do so by writing functions.  We illustrate by creating a custom check
for either a square numeric matrix or a scalar numeric:

```{r}
is.sqr_mx <- function(x) is.matrix(x) && ncol(x) == nrow(x)
is.sqr_num_mx_or_sclr_num <- function(x)
  is.numeric(x) && (is.sqr_mx(x) || length(x) == 1)

rect.mx <- matrix(1:12, 3)

compound_stopifnot <- function(x) {
  stopifnot(is.sqr_num_mx_or_sclr_num(x))
}
compound_stopifnot(rect.mx)

compound_assertthat <- function(x) {
  assert_that(is.sqr_num_mx_or_sclr_num(x))
}
compound_assertthat(rect.mx)
```

The main drawback from this approach is the somewhat uninformative error
message.

`vetr` is similar, except that you can combine template and standard tokens as
language objects and retain the more granular error reporting:

```{r}
vetr.sqr.num.mx <- quote(matrix(numeric(), 0) && ncol(.) == nrow(.))
vetr.sqr.num.mx.or.sclr.num <- quote(vetr.sqr.num.mx || numeric(1L))

compound_vetr <- function(x) {
  vetr(vetr.sqr.num.mx.or.sclr.num)
}
compound_vetr(rect.mx)
```

You can use `assert` with `check*` functions in, but we lose some of the
expressiveness of the error messages:

```{r}
checkSquareNumMatrix <- function(x)
  isTRUE(checkMatrix(x, mode='numeric')) && nrow(x) == ncol(x)

compound_checkmate <- function(x) {
  assert(checkSquareNumMatrix(x), checkNumber(x, na.ok=TRUE), combine="or")
}
compound_checkmate(rect.mx)
```

Neither `assertive` nor `ensurer` appear to provide an out of the box mechanism
for combining checks with "or" logic.  `ensurer` does provide a mechanism for
"and" combinations [via `ensures`](#appendix).  To get the "or" logic we need to
rely on the same function we defined for `stopifnot`:

```{r}
compound_ensurer <- function(x) {
  ensure(x, is.sqr_num_mx_or_sclr_num(.))
}
compound_ensurer(rect.mx)

compound_assertive <- function(x) {
  assert_engine(is.sqr_num_mx_or_sclr_num, x=x)
}
compound_assertive(rect.mx)
```

Outside of `stopifnot` every package has a mechanism for manually specifying
more informative error messages, but we do not explore those here.

## Benchmarks

```{r child='./compare-nav.Rmd'}
```

We benchmark the functions with `mb`, a thin wrapper around `microbenchmark`
(see the [appendix](#appendix) for its definition).  Note that the `mean`
numbers may be skewed by outlier timings caused by `rmarkdown`.  We also focus
on timings for checks that succeed.

Starting with the simple checks:

```{r mb_define, echo=FALSE}
mb <- function(...) {
  mb.call <- match.call()
  mb.call[[1]] <- quote(microbenchmark::microbenchmark)

  mb.res <- summary(eval(mb.call, envir=parent.frame()))
  mb.res <- mb.res[order(mb.res$median), ]
  mb.res[, -1] <- lapply(
    mb.res[, -1], function(x) format(round(x), big.mark=",")
  )
  cat(
    sprintf("Unit: %s, neval: %s\n\n", attr(mb.res, 'unit'), mb.res$neval[1])
  )
  print(mb.res[, c('expr', 'lq', 'median', 'uq', 'mean')], quote=FALSE)
}
```
```{r, echo=FALSE}
mb(
  simple_stopifnot(pi, TRUE),
  simple_vetr(pi, TRUE),
  simple_assertive(pi, TRUE),
  simple_assertthat(pi, TRUE),
  simple_ensurer(pi, TRUE),
  simple_checkmate(pi, TRUE)
)
```

`stopifnot` and `checkmate` lead the way, with `vetr` not too far behind.

One could argue that the performance differences here are trivial.  After all,
even the slowest approach clocks in under a millisecond.  However, given the
prevalence of split-apply-combine style analysis, where a single function could
be applied to thousands or even millions of data groups, the performance
differences shown here can have a substantial impact on overall computation
time.

For complex objects `vetr` takes the lead:

```{r, echo=FALSE}
mb(
  complex_assertive(iris),
  complex_assertthat(iris),
  complex_ensurer(iris),
  complex_checkmate(iris),
  complex_stopifnot(iris),
  complex_vetr(iris)
)
```

In fact, the overall time is comparable with that of the simple checks; this is
because most of the overhead for `vetr` comes from the two `match.call` calls it
must make in R to match arguments.

Checking vector values in a long vector (note, `assertive` is **3 orders of
magnitude slower**, likely because it applies an R function call to each element,
so we run it fewer times):

```{r}
str.pos.vec <- runif(5e5) + 1  # test with a 500K long vector
```
```{r, echo=FALSE}
mb(times=10,
  vector_assertthat(str.pos.vec),
  vector_ensurer(str.pos.vec),
  vector_checkmate(str.pos.vec),
  vector_stopifnot(str.pos.vec),
  vector_vetr(str.pos.vec)
)
mb(times=1,
  vector_assertive(str.pos.vec)
)
```

`vetr` is now the fastest option because we use `vetr::all_bw` instead of the
semantically equivalent `!anyNA(.) && all(. > 0)` expression.  `all_bw` is
implemented in C and avoids the intermediate vectors required to evaluate the
standard R version.  `checkmate` does the same with `qassert`.

`stopifnot` does a little better in the compound tests:

```{r}
sqr.mx <- matrix(1:9, 3)
```
```{r, echo=FALSE}
mb(
  compound_assertive(sqr.mx),
  compound_assertthat(sqr.mx),
  compound_ensurer(sqr.mx),
  compound_checkmate(sqr.mx),
  compound_stopifnot(sqr.mx),
  compound_vetr(sqr.mx)
)
```

## Conclusions

```{r child='./compare-nav.Rmd'}
```

Take these with a grain of salt, as they are written by the `vetr` author:

In favor of `vetr`:

* `vetr` is the best package for checking complex S3 structure
* `vetr` is fastest for non-trivial checks

Against `vetr`:

* New package with an extensive test suite, but limited "real-world"
  testing
* Template concept is designed to be intuitive, but the actual implementation is
  complex, which in corner cases may lead to unintuitive outcomes

If you are tired of dealing with checks for non-trivial S3 objects and are
willing to be on the bleeding edge, `vetr` is for you.  If not, we would
recommend `checkmate` as it is fast, well established, and more expressive than
the other options.

## Appendix

```{r child='./compare-nav.Rmd'}
```

### Definitions

Definitions of terms as we use them in this document.  They may have different
definitions elsewhere.

<dl>
  <dt><a name='predicate-function'></a>Predicate Function</dt>
  <dd>
  Function that typically accepts one non-optional argument and returns TRUE
  or FALSE according to whether that argument conforms to a requirement.
  `isTRUE(x)`, `is.numeric(x)`, etc. are common examples of Predicate Functions.
  `identical(x, y)` is a two argument Predicate Function.
  </dd>
  <dt><a name='check-function'></a>Check Function</dt>
  <dd>
  Similar to a Predicate Function, arguments and may return either TRUE or a
  vector of only TRUE values on success, and something else on failure.
  `all.equal(x, y)` is a common example.  Check Functions should be used within
  `isTRUE(all(check_fun(...)))` to establish success or failure, unless they are
  used within `stopifnot` or `vetr` where such a check is implicit.
  </dd>
  <dt><a name='check-expression'></a>Check Expression</dt>
  <dd>
  A collection of calls to Check and/or Predicate Functions combined with
  logical operators.  For example `!anyNA(x) && x > 0`.
  </dd>
  <dt><a name='vetting-expression'></a>Vetting Expression</dt>
  <dd>
  Like a Check Expression, but augmented for use in `vetr`.  In addition to
  Check and Predicate Function calls, it can include Templates Tokens.
  References to the object being checked should be made with `.`.  For example
  `numeric(1L) && !is.na(.) && x > 0`, is made up of three tokens, where
  `numeric(1L)` is a Template Token, and `!is.na(.)` and `x > 0` are Standard
  Tokens.  See `vignette(package='vetr', 'vetr')` for more details..
  </dd>
  <dt><a name='template-token'></a>Template Token</dt>
  <dd>
  Part of a Vetting Expression that should be treated as a template by `vetr`.
  It should resolve to an R object when it is evaluated in the calling frame of
  the enclosing function to the `vetr` call.
  See `vignette(package='vetr', 'vetr')` for more details.
  </dd>
  <dt><a name='standard-token'></a>Standard Token</dt>
  <dd>
  Part of a Vetting Expression that should be treated as a standard R
  expression.  If `isTRUE(all(evaluated_standard_token))` then the token will be
  considered to pass.  Standard Tokens are identified by the presence of a `.`
  symbol within a token.  You can also wrap expressions in `.()` to mark them as
  standard tokens.  If you need to use the `.` symbol for other purposes escape
  it with another `.` (i.e. to use a literal `.`, use `..`).
  See `vignette(package='vetr', 'vetr')` for more details.
  </dd>
  <dt><a name='vetting-token'></a>Vetting Token</dt>
  <dd>
  Component pieces of Vetting Expressions.  May be either Standard Tokens or
  Template Tokens.  Vetting Tokens are the arguments to "top level" `&&`, `||`,
  and `(` calls.  For example, in the Vetting Expression
  `!anyNA(.) && I(. > 0 && interactive())` there are two  Vetting Tokens:
  `!anyNA(.)` and `I(. > 0 && interactive())`.  The `&&` inside `I(...)` is not
  considered to be at the "top level" because of the intervening `I` call.
  </dd>
</dl>

### References

* Vignettes and other documentation for the reviewed packages

### Ancillary Code

#### microbenchmark Thin Wrapper

```{r mb_define}
```

#### Ensurer Compound Contracts

`ensurer` "and" contracts:

```{r}
ensurer_num_mx <- ensures(is.numeric(.) && is.matrix(.))
ensurer_sqr <- ensures(ncol(.) == nrow(.))
ensurer_sqr_mx <- ensures(+ensurer_num_mx, +ensurer_sqr)  # and combination

compound_ensurer_a <- function(x) {
  ensurer_sqr_mx(x)
}
compound_ensurer_a(rect.mx)
```

#### Complex Objects Appendix

Complex objects for other packages:

```{r iris.other}
```

### End Notes

<sup>1</sup>:<a name='sup-1'></a>
  The only noteworthy difference between the two is that `assertthat`
  requires Check Expressions to evaluate to TRUE or FALSE, whereas `stopifnot`
  accepts anything, with all TRUE vectors considered a success and all else
  failure.
<sup>1</sup>: Both `ensurer` and `checkmate` use the square matrix test in their
respective vignettes.


